<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta property="og:url" content="https://theme-hope.vuejs.press/zh/config/theme/layout.html/java/new-features/java21.html"><meta property="og:site_name" content="有梦想的鱼-开源博客"><meta property="og:title" content="Java 21 新特性概览"><meta property="og:description" content="| 430: | String Templates (Preview)| 什么是 String Templates? String Templates 是 Java 15 中引入的一个新特性，它允许我们在字符串中使用占位符来动态替换变量的值。它提供了一种更简洁、更直观的方式来构建字符串，而不需要使用传统的字符串拼接或格式化方法。 为什么需要 String Templates? 在传统的 Java 中，我们通常使用字符串拼接或格式化方法来构建动态字符串。这种方式需要手动处理变量的值，并且容易出错。而且，当字符串中包含大量变量时，代码会变得冗长且难以维护。 String Templates 的引入解决了这个问题，它提供了一种更简洁、更易读的方式来构建动态字符串。通过使用占位符，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。 String Templates 的实现原理? String Templates 的实现原理是通过在字符串中使用占位符{} 解析为一个特殊的表达式，并将其转换为对应的变量值。这个过程是在编译时完成的，所以在运行时不会有额外的性能开销。 String Templates 的优点"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-12-15T03:58:38.000Z"><meta property="article:author" content="有梦想的鱼🐟"><meta property="article:tag" content="Java新特性"><meta property="article:modified_time" content="2023-12-15T03:58:38.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Java 21 新特性概览","image":[""],"dateModified":"2023-12-15T03:58:38.000Z","author":[{"@type":"Person","name":"有梦想的鱼🐟"}]}</script><link rel="alternate" type="application/rss+xml" href="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml" title="有梦想的鱼-开源博客 RSS Feed"><title>Java 21 新特性概览 | 有梦想的鱼-开源博客</title><meta name="description" content="| 430: | String Templates (Preview)| 什么是 String Templates? String Templates 是 Java 15 中引入的一个新特性，它允许我们在字符串中使用占位符来动态替换变量的值。它提供了一种更简洁、更直观的方式来构建字符串，而不需要使用传统的字符串拼接或格式化方法。 为什么需要 String Templates? 在传统的 Java 中，我们通常使用字符串拼接或格式化方法来构建动态字符串。这种方式需要手动处理变量的值，并且容易出错。而且，当字符串中包含大量变量时，代码会变得冗长且难以维护。 String Templates 的引入解决了这个问题，它提供了一种更简洁、更易读的方式来构建动态字符串。通过使用占位符，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。 String Templates 的实现原理? String Templates 的实现原理是通过在字符串中使用占位符{} 解析为一个特殊的表达式，并将其转换为对应的变量值。这个过程是在编译时完成的，所以在运行时不会有额外的性能开销。 String Templates 的优点">
    <meta name="keywords" content="自我提升,效率提升,开源工具,学习笔记" />
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #252232;
      }

      html,
      body {
        background: var(--bg-color);
      }
      .wwads-cn * {
        color: var(--text-color) !important;
      }
      @media screen and (max-width: 1300px) {
        .wwads-cn {
          display: none;
        }
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-eb5bfcb9.css" as="style"><link rel="stylesheet" href="/assets/style-eb5bfcb9.css">
    <link rel="modulepreload" href="/assets/app-37a49dbd.js"><link rel="modulepreload" href="/assets/java21.html-49ebc7ec.js"><link rel="modulepreload" href="/assets/java21.html-22842cde.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-c27b6911.js">
    <!-- <script type="text/javascript" charset="UTF-8" src="https://cdn.wwads.cn/js/makemoney.js" async></script> -->
	  <!-- <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7585955822109216"
     crossorigin="anonymous"></script> -->
    <!-- Matomo 此区块为统计代码，请删除-->
    <script>
      var _paq = window._paq = window._paq || [];
      /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
      _paq.push(['trackPageView']);
      _paq.push(['enableLinkTracking']);
      (function() {
        var u="https://piwik.seoipo.com/";
        _paq.push(['setTrackerUrl', u+'matomo.php']);
        _paq.push(['setSiteId', '7']);
        var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
        g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
      })();
    </script>
    <!-- End Matomo Code 此区块为统计代码，请删除-->
  </head>
  <body>
    <!-- <div class="wwads-cn wwads-vertical wwads-sticky" data-id="255" data-sticky-position="left" style="max-width:180px; background-color:var(--bg-color);"></div> -->
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.png" alt="有梦想的鱼-开源博客"><!----><span class="vp-site-name hide-in-pad">有梦想的鱼-开源博客</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="vp-link nav-link" href="/"><span class="font-icon icon iconfont icon-home" style=""></span>首页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="代码"><span class="title"><span class="font-icon icon iconfont icon-code" style=""></span>代码</span><span class="arrow"></span><ul class="nav-dropdown"></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="应用"><span class="title"><span class="font-icon icon iconfont icon-app" style=""></span>应用</span><span class="arrow"></span><ul class="nav-dropdown"></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="生活"><span class="title"><span class="font-icon icon iconfont icon-emmet" style=""></span>生活</span><span class="arrow"></span><ul class="nav-dropdown"></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="工具"><span class="title"><span class="font-icon icon iconfont icon-tool" style=""></span>工具</span><span class="arrow"></span><ul class="nav-dropdown"></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="网站相关"><span class="title"><span class="font-icon icon iconfont icon-info" style=""></span>网站相关</span><span class="arrow"></span><ul class="nav-dropdown"></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/wangfeng1996/LearnData" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button type="button" class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/home.html"><span class="font-icon icon iconfont icon-creative" style=""></span>学习<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title"> java</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-star" style=""></span><span class="vp-sidebar-title">java新特性</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java8.html"><!---->Java 8 新特性实战<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java9.html"><!---->Java 9 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java10.html"><!---->Java 10 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java11.html"><!---->Java 11 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java12-13.html"><!---->Java 12  &amp; 13 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java14-15.html"><!---->Java 14  &amp; 15 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java16.html"><!---->Java 16 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java17.html"><!---->Java 17 新特性概览（重要）<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java18.html"><!---->Java 18 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java19.html"><!---->Java 19 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link vp-sidebar-link vp-sidebar-page" href="/java/new-features/java20.html"><!---->Java 20 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/java/new-features/java21.html"><!---->Java 21 新特性概览<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li></ul></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-tool" style=""></span><span class="vp-sidebar-title">开发工具</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">🏗️ 网站部署</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-code" style=""></span><span class="vp-sidebar-title">代码学习</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-caozuoxitong" style=""></span><span class="vp-sidebar-title">操作系统</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">🪟 系统问题</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">🛖 生活记录</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Java 21 新特性概览</h1><div class="page-info"><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category4 clickable" role="navigation">Java</span><!--]--><meta property="articleSection" content="Java"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag5 clickable" role="navigation">Java新特性</span><!--]--><meta property="keywords" content="Java新特性"></span><span class="page-word-info" aria-label="字数🔠" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 15950 字</span><meta property="wordCount" content="15950"></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 53 分钟</span><meta property="timeRequired" content="PT53M"></span></div><hr></div><!----><!----><div class="theme-hope-content"><p>| 430: | String Templates (<a href="https://openjdk.org/jeps/430" target="_blank" rel="noopener noreferrer">Preview<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>)|</p><ol><li>什么是 String Templates?<br> String Templates 是 Java 15 中引入的一个新特性，它允许我们在字符串中使用占位符来动态替换变量的值。它提供了一种更简洁、更直观的方式来构建字符串，而不需要使用传统的字符串拼接或格式化方法。</li><li>为什么需要 String Templates?<br> 在传统的 Java 中，我们通常使用字符串拼接或格式化方法来构建动态字符串。这种方式需要手动处理变量的值，并且容易出错。而且，当字符串中包含大量变量时，代码会变得冗长且难以维护。<br> String Templates 的引入解决了这个问题，它提供了一种更简洁、更易读的方式来构建动态字符串。通过使用占位符，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。</li><li>String Templates 的实现原理?<br> String Templates 的实现原理是通过在字符串中使用占位符<mjx-container class="MathJax" jax="SVG" style="position:relative;"><svg style="vertical-align:-0.464ex;" xmlns="http://www.w3.org/2000/svg" width="148.708ex" height="2.161ex" role="img" focusable="false" viewBox="0 -750 65729 955" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"></g><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">来</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">表</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">示</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">变</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(5000,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">在</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">运</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">行</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(11000,0)"><path data-c="1D43D" d="M447 625Q447 637 354 637H329Q323 642 323 645T325 664Q329 677 335 683H352Q393 681 498 681Q541 681 568 681T605 682T619 682Q633 682 633 672Q633 670 630 658Q626 642 623 640T604 637Q552 637 545 623Q541 610 483 376Q420 128 419 127Q397 64 333 21T195 -22Q137 -22 97 8T57 88Q57 130 80 152T132 174Q177 174 182 130Q182 98 164 80T123 56Q115 54 115 53T122 44Q148 15 197 15Q235 15 271 47T324 130Q328 142 387 380T447 625Z"></path></g><g data-mml-node="mi" transform="translate(11633,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(12162,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(12647,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(13176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">编</text></g><g data-mml-node="mi" transform="translate(14176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">译</text></g><g data-mml-node="mi" transform="translate(15176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">器</text></g><g data-mml-node="mi" transform="translate(16176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">会</text></g><g data-mml-node="mi" transform="translate(17176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">将</text></g><g data-mml-node="mi" transform="translate(18176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">这</text></g><g data-mml-node="mi" transform="translate(19176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">些</text></g><g data-mml-node="mi" transform="translate(20176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">占</text></g><g data-mml-node="mi" transform="translate(21176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">位</text></g><g data-mml-node="mi" transform="translate(22176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">符</text></g><g data-mml-node="mi" transform="translate(23176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">替</text></g><g data-mml-node="mi" transform="translate(24176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">换</text></g><g data-mml-node="mi" transform="translate(25176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(26176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">实</text></g><g data-mml-node="mi" transform="translate(27176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">际</text></g><g data-mml-node="mi" transform="translate(28176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(29176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">变</text></g><g data-mml-node="mi" transform="translate(30176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g><g data-mml-node="mi" transform="translate(31176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">值</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(32176,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g><g data-mml-node="mi" transform="translate(33176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">具</text></g><g data-mml-node="mi" transform="translate(34176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">体</text></g><g data-mml-node="mi" transform="translate(35176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">来</text></g><g data-mml-node="mi" transform="translate(36176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">说</text></g><g data-mml-node="mi" transform="translate(37176,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(38176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">当</text></g><g data-mml-node="mi" transform="translate(39176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">我</text></g><g data-mml-node="mi" transform="translate(40176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">们</text></g><g data-mml-node="mi" transform="translate(41176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">使</text></g><g data-mml-node="mi" transform="translate(42176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">用</text></g><g data-mml-node="mi" transform="translate(43176,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(43821,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(44182,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(44633,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(44978,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(45578,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(46055,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(46759,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(47225,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(48103,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(48606,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(48904,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(49433,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(49794,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(50260,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(50729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">时</text></g><g data-mml-node="mi" transform="translate(51729,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(52729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">编</text></g><g data-mml-node="mi" transform="translate(53729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">译</text></g><g data-mml-node="mi" transform="translate(54729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">器</text></g><g data-mml-node="mi" transform="translate(55729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">会</text></g><g data-mml-node="mi" transform="translate(56729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">将</text></g><g data-mml-node="mi" transform="translate(57729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">字</text></g><g data-mml-node="mi" transform="translate(58729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">符</text></g><g data-mml-node="mi" transform="translate(59729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">串</text></g><g data-mml-node="mi" transform="translate(60729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">中</text></g><g data-mml-node="mi" transform="translate(61729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(62729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">占</text></g><g data-mml-node="mi" transform="translate(63729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">位</text></g><g data-mml-node="mi" transform="translate(64729,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">符</text></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"></mrow><mi mathvariant="normal">来</mi><mi mathvariant="normal">表</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mrow data-mjx-texclass="ORD"><mo>。</mo></mrow><mi mathvariant="normal">在</mi><mi mathvariant="normal">运</mi><mi mathvariant="normal">行</mi><mi mathvariant="normal">时</mi><mi>，</mi><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">编</mi><mi mathvariant="normal">译</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">些</mi><mi mathvariant="normal">占</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">际</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">值</mi><mrow data-mjx-texclass="ORD"><mo>。</mo></mrow><mi mathvariant="normal">具</mi><mi mathvariant="normal">体</mi><mi mathvariant="normal">来</mi><mi mathvariant="normal">说</mi><mi>，</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>T</mi><mi>e</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">时</mi><mi>，</mi><mi mathvariant="normal">编</mi><mi mathvariant="normal">译</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">占</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">符</mi></math></mjx-assistive-mml></mjx-container>{}<br> 解析为一个特殊的表达式，并将其转换为对应的变量值。这个过程是在编译时完成的，所以在运行时不会有额外的性能开销。</li><li>String Templates 的优点</li></ol><p>简洁易读：使用占位符${}来表示变量，使得代码更加简洁、易读。<br> 类型安全：String Templates 在编译时会进行类型检查，确保变量的类型与占位符的类型匹配，避免了运行时的类型错误。<br> 性能优化：String Templates 的解析过程是在编译时完成的，所以在运行时不会有额外的性能开销。<br> 可扩展性：String Templates 支持自定义的格式化函数，可以根据需求进行扩展。</p><ol start="5"><li>String Templates 的缺点</li></ol><p>兼容性：String Templates 是 Java 15 中引入的新特性，需要使用 Java 15 或更高版本的 JDK 才能使用。<br> 语法限制：String Templates 的占位符${}只能用于表示变量，不能用于执行任意的表达式。<br> 可读性：当字符串中包含大量的占位符时，可能会降低代码的可读性。</p><ol start="6"><li>String Templates 的使用示例<br> 下面是一个使用 String Templates 的简单示例：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>   String name <span class="token operator">=</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">;</span>
   int age <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span>
   String message <span class="token operator">=</span> <span class="token string">&quot;My name is <span class="token variable">${name}</span> and I&#39;m <span class="token variable">${age}</span> years old.&quot;</span><span class="token punctuation">;</span>
   System.out.println<span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>My name is Alice and I&#39;m <span class="token number">25</span> years old.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="7"><li>String Templates 的使用注意事项</li></ol><p>占位符<mjx-container class="MathJax" jax="SVG" style="position:relative;"><svg style="vertical-align:-0.452ex;" xmlns="http://www.w3.org/2000/svg" width="45.647ex" height="2.149ex" role="img" focusable="false" viewBox="0 -750 20176 950" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"></g><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">中</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">变</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">量</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">名</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">必</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">须</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">是</text></g><g data-mml-node="mi" transform="translate(8000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">有</text></g><g data-mml-node="mi" transform="translate(9000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">效</text></g><g data-mml-node="mi" transform="translate(10000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">的</text></g><g data-mml-node="mi" transform="translate(11000,0)"><path data-c="1D43D" d="M447 625Q447 637 354 637H329Q323 642 323 645T325 664Q329 677 335 683H352Q393 681 498 681Q541 681 568 681T605 682T619 682Q633 682 633 672Q633 670 630 658Q626 642 623 640T604 637Q552 637 545 623Q541 610 483 376Q420 128 419 127Q397 64 333 21T195 -22Q137 -22 97 8T57 88Q57 130 80 152T132 174Q177 174 182 130Q182 98 164 80T123 56Q115 54 115 53T122 44Q148 15 197 15Q235 15 271 47T324 130Q328 142 387 380T447 625Z"></path></g><g data-mml-node="mi" transform="translate(11633,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(12162,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mi" transform="translate(12647,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(13176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">标</text></g><g data-mml-node="mi" transform="translate(14176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">识</text></g><g data-mml-node="mi" transform="translate(15176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">符</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(16176,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g><g data-mml-node="mi" transform="translate(17176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">占</text></g><g data-mml-node="mi" transform="translate(18176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">位</text></g><g data-mml-node="mi" transform="translate(19176,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">符</text></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"></mrow><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">变</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">名</mi><mi mathvariant="normal">必</mi><mi mathvariant="normal">须</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">效</mi><mi mathvariant="normal">的</mi><mi>J</mi><mi>a</mi><mi>v</mi><mi>a</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">识</mi><mi mathvariant="normal">符</mi><mrow data-mjx-texclass="ORD"><mo>。</mo></mrow><mi mathvariant="normal">占</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">符</mi></math></mjx-assistive-mml></mjx-container>{}中的变量值可以是任意类型，编译器会自动进行类型转换。<br> 如果变量值为 null，占位符<mjx-container class="MathJax" jax="SVG" style="position:relative;"><svg style="vertical-align:-0.464ex;" xmlns="http://www.w3.org/2000/svg" width="73.351ex" height="2.161ex" role="img" focusable="false" viewBox="0 -750 32421 955" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"></g><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">会</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">被</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">替</text></g><g data-mml-node="mi" transform="translate(3000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">换</text></g><g data-mml-node="mi" transform="translate(4000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">为</text></g><g data-mml-node="mi" transform="translate(5000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">字</text></g><g data-mml-node="mi" transform="translate(6000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">符</text></g><g data-mml-node="mi" transform="translate(7000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">串</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8000,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"></path></g></g></g><g data-mml-node="mi" transform="translate(8550,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(9150,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(9722,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(10020,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(10318,0)"><g data-mml-node="mo"><g data-c="2033"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z" transform="translate(275,0)"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(10868,0)"><g data-mml-node="mo"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">。</text></g></g><g data-mml-node="mi" transform="translate(11868,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(12513,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(12874,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(13325,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(13670,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(14270,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(14747,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><g data-mml-node="mi" transform="translate(15451,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(15917,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(16795,0)"><path data-c="1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"></path></g><g data-mml-node="mi" transform="translate(17298,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(17596,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(18125,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(18486,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(18952,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path></g><g data-mml-node="mi" transform="translate(19421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">支</text></g><g data-mml-node="mi" transform="translate(20421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">持</text></g><g data-mml-node="mi" transform="translate(21421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">嵌</text></g><g data-mml-node="mi" transform="translate(22421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">套</text></g><g data-mml-node="mi" transform="translate(23421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">使</text></g><g data-mml-node="mi" transform="translate(24421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">用</text></g><g data-mml-node="mi" transform="translate(25421,0)"><text data-variant="italic" transform="scale(1,-1)" font-size="884px" font-family="serif" font-style="italic">，</text></g><g data-mml-node="mi" transform="translate(26421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">可</text></g><g data-mml-node="mi" transform="translate(27421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">以</text></g><g data-mml-node="mi" transform="translate(28421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">在</text></g><g data-mml-node="mi" transform="translate(29421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">占</text></g><g data-mml-node="mi" transform="translate(30421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">位</text></g><g data-mml-node="mi" transform="translate(31421,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">符</text></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"></mrow><mi mathvariant="normal">会</mi><mi mathvariant="normal">被</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi><mi mathvariant="normal">为</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">串</mi><mrow data-mjx-texclass="ORD"><mo data-mjx-pseudoscript="true">&quot;</mo></mrow><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi><mrow data-mjx-texclass="ORD"><mo data-mjx-pseudoscript="true">&quot;</mo></mrow><mrow data-mjx-texclass="ORD"><mo>。</mo></mrow><mi>S</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>T</mi><mi>e</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">支</mi><mi mathvariant="normal">持</mi><mi mathvariant="normal">嵌</mi><mi mathvariant="normal">套</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi>，</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">占</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">符</mi></math></mjx-assistive-mml></mjx-container>{}中使用其他占位符。</p><ol start="8"><li>总结<br> String Templates 是 Java 15 中引入的一个新特性，它提供了一种更简洁、更直观的方式来构建动态字符串。通过使用占位符${}<br> ，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。String<br> Templates 具有简洁易读、类型安全、性能优化和可扩展性等优点，但也存在兼容性、语法限制和可读性等缺点。在使用 String<br> Templates 时，需要注意占位符的命名规则和变量值的类型。<br> | 431: | <a href="https://openjdk.org/jeps/431" target="_blank" rel="noopener noreferrer">Sequenced Collections<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |<br> Sequenced Collections</li><li>什么是 Sequenced Collections？<br> Sequenced Collections 是 Java 中的一个新特性，它是通过 JEP 431 引入的。Sequenced<br> Collections 是一种新的集合类型，它提供了一种有序的、线程安全的集合实现。它的目标是提供一种高效的、可扩展的有序集合，以满足在多线程环境下处理大量数据的需求。</li><li>为什么需要 Sequenced Collections？<br> 在并发编程中，处理大量数据时，有序集合是非常常见的需求。然而，Java 标准库中的集合类（如 ArrayList、LinkedList<br> 等）并不是线程安全的，因此在多线程环境下使用它们可能会导致数据不一致的问题。为了解决这个问题，开发人员通常需要使用同步机制（如<br> synchronized 关键字或 Lock 对象）来保证集合的线程安全性，但这会带来额外的开销和复杂性。<br> Sequenced Collections 的目标就是提供一种高效的、可扩展的有序集合，以解决在多线程环境下处理大量数据时的线程安全问题。</li><li>Sequenced Collections 的实现原理<br> Sequenced Collections 的实现基于一种称为&quot;Sequenced Locks&quot;的机制。Sequenced<br> Locks 是一种特殊的锁机制，它允许多个线程同时读取集合中的数据，但只允许一个线程进行写操作。这种机制可以提高并发性能，同时保证数据的一致性。<br> 在 Sequenced<br> Collections 中，每个元素都有一个唯一的序列号，用于标识元素的顺序。读操作可以并发进行，而写操作则需要获取锁来保证原子性。当一个线程进行写操作时，其他线程可以继续读取集合中的数据，但不能进行写操作，直到写操作完成。</li><li>Sequenced Collections 的优点</li></ol><p>线程安全：Sequenced Collections 提供了线程安全的集合实现，可以在多线程环境下安全地访问和修改集合中的数据。<br> 高效性能：Sequenced Collections 使用了 Sequenced Locks 机制，可以提高并发性能，同时保证数据的一致性。<br> 可扩展性：Sequenced Collections 的设计考虑了可扩展性，可以处理大量数据的并发访问。</p><ol start="5"><li>Sequenced Collections 的缺点</li></ol><p>额外开销：Sequenced Collections 的实现需要维护元素的序列号和锁机制，这会带来一定的额外开销。<br> 写操作的延迟：由于写操作需要获取锁来保证原子性，可能会导致其他线程在写操作完成之前无法进行写操作。</p><ol start="6"><li>Sequenced Collections 的使用示例<br> 下面是一个使用 Sequenced Collections 的简单示例：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">SequencedHashMap</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SequencedCollectionsExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SequencedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SequencedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 添加元素</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;Apple&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;Banana&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;Orange&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 获取元素</span>
        <span class="token class-name">String</span> fruit <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fruit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: Banana</span>

        <span class="token comment">// 遍历元素</span>
        map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出:</span>
        <span class="token comment">// 1: Apple</span>
        <span class="token comment">// 2: Banana</span>
        <span class="token comment">// 3: Orange</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们使用了 SequencedHashMap 来创建一个有序的、线程安全的集合。我们可以使用 put 方法添加元素，使用 get<br> 方法获取元素，使用 forEach 方法遍历元素。</p><ol start="7"><li>Sequenced Collections 的其他注意事项</li></ol><p>Sequenced Collections 是 Java 标准库的一部分，从 Java 17 开始引入。<br> Sequenced Collections 提供了多种集合类型，如 SequencedHashMap、SequencedArrayList 等。<br> Sequenced Collections 可以与其他 Java 集合类（如 ArrayList、LinkedList 等）一起使用，以满足不同的需求。</p><ol start="8"><li>总结<br> Sequenced Collections 是 Java 中的一个新特性，它提供了一种有序的、线程安全的集合实现。它通过使用 Sequenced<br> Locks 机制来保证线程安全性和并发性能。Sequenced Collections 具有高效性能、可扩展性等优点，但也存在额外开销和写操作延迟的缺点。在使用<br> Sequenced<br> Collections 时，我们可以创建 SequencedHashMap、SequencedArrayList 等集合类型，并使用 put、get、forEach 等方法来操作集合中的数据。</li></ol><p>| 439: | <a href="https://openjdk.org/jeps/439" target="_blank" rel="noopener noreferrer">Generational ZGC<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |</p><ol><li>什么是 Generational ZGC?<br> Generational ZGC（Z Garbage Collector）是一种用于 Java 虚拟机（JVM）的垃圾回收器。它是 OpenJDK<br> 项目中的一个特性，旨在提供低延迟和高吞吐量的垃圾回收解决方案。</li><li>为什么需要 Generational ZGC?<br> 传统的垃圾回收器在处理大型堆内存时可能会导致长时间的停顿，这对于需要快速响应和低延迟的应用程序来说是不可接受的。Generational<br> ZGC 的目标是减少这些停顿时间，并且能够处理非常大的堆内存。</li><li>Generational ZGC 的实现原理<br> Generational ZGC 基于分代垃圾回收的概念，将堆内存划分为多个代。其中包括 Young Generation（年轻代）和 Old<br> Generation（老年代）。具体的实现原理如下：<br> 年轻代（Young Generation）</li></ol><p>年轻代使用了 Region 的概念，将整个年轻代划分为多个大小相等的区域。<br> 每个区域都有一个指针指向下一个可用的区域，形成一个链表结构。<br> 当对象被创建时，它们首先被分配到年轻代的某个区域中。<br> 当一个区域被填满时，会触发一次年轻代垃圾回收（Minor GC）。<br> Minor GC 使用了并行和压缩算法来回收不再使用的对象。</p><p>老年代（Old Generation）</p><p>老年代是存放生命周期较长的对象的区域。<br> 当一个对象在年轻代经历了多次垃圾回收后仍然存活，它将被晋升到老年代。<br> 当老年代空间不足时，会触发一次老年代垃圾回收（Major GC）。<br> Major GC 使用了并发标记和并行清理算法来回收不再使用的对象。</p><p>并发处理<br> Generational ZGC 采用了并发处理的方式来减少停顿时间。具体包括：</p><p>年轻代垃圾回收过程中，应用程序可以继续执行。<br> 在老年代垃圾回收过程中，应用程序也可以继续执行，只有在最后的清理阶段才会产生短暂的停顿。</p><ol start="4"><li>Generational ZGC 的优点</li></ol><p>低延迟：Generational ZGC 通过并发处理和分代回收的策略，实现了非常低的停顿时间，适合对响应时间要求高的应用场景。<br> 高吞吐量：Generational ZGC 在尽可能减少停顿时间的同时，也能保持较高的垃圾回收吞吐量。<br> 大堆支持：Generational ZGC 可以处理非常大的堆内存，适用于需要大内存容量的应用程序。</p><ol start="5"><li>Generational ZGC 的缺点</li></ol><p>性能开销：由于并发处理和分代回收的策略，Generational ZGC 会带来一定的性能开销。这主要体现在 CPU 和内存的使用上。<br> 配置复杂：Generational ZGC 有一些与性能相关的配置参数，需要根据具体场景进行调整，对于不熟悉的用户来说可能比较复杂。</p><ol start="6"><li><p>Generational ZGC 的使用示例<br> 以下是一个简单的 Java 代码示例，展示了如何启用 Generational ZGC：<br> java复制代码java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC YourApplication</p></li><li><p>Generational ZGC 的使用注意事项</p></li></ol><p>Generational ZGC 是 OpenJDK 项目中的新特性，虽然已经相当稳定，但仍然建议在生产环境中进行充分测试。<br> 在使用 Generational ZGC 时，建议监控系统资源使用情况，以便及时调整配置参数或采取其他措施来优化性能。</p><ol start="8"><li>总结<br> Generational ZGC 是一种用于 Java 虚拟机的垃圾回收器，旨在提供低延迟和高吞吐量的垃圾回收解决方案。它通过并发处理和分代回收的策略，实现了非常低的停顿时间，并且能够处理非常大的堆内存。然而，使用<br> Generational<br> ZGC 需要注意性能开销和配置复杂性。<br> | 440: | <a href="https://openjdk.org/jeps/440" target="_blank" rel="noopener noreferrer">Record Patterns<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |</li><li>什么是 Record Patterns?<br> Record Patterns 是 Java 16 中引入的一个新特性，它允许我们在模式匹配中使用记录类型（record<br> types）。记录类型是一种新的类声明形式，用于定义不可变的数据对象。而 Record Patterns<br> 则提供了一种简洁的方式来进行模式匹配，并且可以方便地从记录类型中提取字段值。</li><li>为什么需要 Record Patterns?<br> 在传统的 Java 编程中，当我们需要对某个对象的属性进行判断和提取时，通常需要手动编写大量的代码来完成这些操作。而引入<br> Record<br> Patterns 可以极大地简化这个过程，使得代码更加清晰、简洁，并且减少了出错的可能性。</li><li>Record Patterns 的实现原理<br> Record Patterns 的实现原理主要涉及两个方面：记录类型和模式匹配。<br> 记录类型<br> 记录类型是一种新的类声明形式，通过 record 关键字来定义。它自动提供了以下功能：</li></ol><p>自动生成私有 final 字段，并根据构造函数参数初始化这些字段。<br> 自动生成 equals()、hashCode() 和 toString() 方法。<br> 提供了一种紧凑的语法来定义字段和构造函数。</p><p>模式匹配<br> 模式匹配是指根据给定的模式来匹配某个对象，并执行相应的操作。在 Record Patterns 中，我们可以使用 instanceof<br> 关键字和模式变量来进行模式匹配。<br> 具体地说，当我们使用 Record Patterns<br> 进行模式匹配时，编译器会自动为记录类型生成一个模式匹配方法。这个方法接受一个对象作为参数，并根据给定的模式进行匹配。如果匹配成功，则将字段值绑定到相应的模式变量中，从而可以在后续代码中使用。</p><ol start="4"><li>Record Patterns 的优点<br> Record Patterns 带来了以下几个优点：</li></ol><p>简洁性：使用 Record Patterns 可以大大简化对记录类型的模式匹配操作，减少冗余代码。<br> 可读性：Record Patterns 提供了一种直观、清晰的语法，使得代码更易于理解和维护。<br> 安全性：由于 Record Patterns 自动生成了 equals() 和 hashCode() 方法，可以避免手动实现这些方法时可能出现的错误。<br> 提高开发效率：Record Patterns 可以减少重复劳动，提高开发效率。</p><ol start="5"><li>Record Patterns 的缺点<br> 尽管 Record Patterns 带来了很多好处，但也存在一些限制和缺点：</li></ol><p>不可变性：记录类型是不可变的，即字段值不能被修改。这意味着如果需要修改某个字段的值，就必须创建一个新的记录对象。<br> 局限性：Record Patterns 目前只能用于记录类型，不能用于其他类。<br> 兼容性：由于 Record Patterns 是在 Java 16 中引入的新特性，因此需要使用 Java 16 或更高版本才能使用。</p><ol start="6"><li>Record Patterns 的使用示例<br> 下面是一个简单的示例，展示了如何使用 Record Patterns 进行模式匹配：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">record</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Person</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>person <span class="token keyword">instanceof</span> <span class="token class-name">Person</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 &quot;Alice&quot;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">age</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 25</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们定义了一个名为 Person 的记录类型，并创建了一个 Person 对象。然后，我们使用 Record Patterns<br> 进行模式匹配，将字段值绑定到模式变量 p 中，并输出字段值。</p><ol start="7"><li>Record Patterns 的使用注意事项<br> 在使用 Record Patterns 时，需要注意以下几点：</li></ol><p>记录类型的字段默认是 final 的，即不能被修改。如果需要修改某个字段的值，就必须创建一个新的记录对象。<br> 记录类型的构造函数参数和字段名称要一致，否则会导致编译错误。<br> 模式匹配方法的命名规则是 <code>match&lt;RecordTypeName&gt;</code>，例如 matchPerson()。</p><ol start="8"><li>总结<br> Record Patterns 是 Java 16 引入的一个新特性，它提供了一种简洁、清晰的方式来进行模式匹配，并且可以方便地从记录类型中提取字段值。使用<br> Record Patterns 可以使代码更加简洁、可读，并提高开发效率。然而，由于记录类型是不可变的，因此在修改字段值时需要创建新的对象。同时，Record<br> Patterns 目前只能用于记录类型，不能用于其他类。</li></ol><p>| 441: | <a href="https://openjdk.org/jeps/441" target="_blank" rel="noopener noreferrer">Pattern Matching for switch<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |</p><ol><li>什么是 Pattern Matching for switch?<br> Pattern Matching for switch 是 Java 14 中引入的一个新特性，它允许在 switch 语句中使用模式匹配。通过这个特性，我们可以更方便地对变量进行类型判断和提取。</li><li>为什么需要 Pattern Matching for switch?<br> 在之前的 Java 版本中，如果我们想要根据不同的类型执行不同的逻辑，通常需要使用多个 if-else 或者 switch-case<br> 来进行判断。这样的代码结构比较冗长，并且容易出错。而 Pattern Matching for switch 的引入，使得我们能够更简洁、清晰地处理这种情况。</li><li>Pattern Matching for switch 的实现原理<br> Pattern Matching for switch 的实现原理主要涉及两个方面：模式匹配和类型推断。<br> 模式匹配<br> 模式匹配是指将某个值与一系列模式进行比较，以确定是否匹配。在 Pattern Matching for switch 中，我们可以使用关键字 case<br> 后跟上模式来进行匹配。例如：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>int result <span class="token operator">=</span> switch <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> String s -<span class="token operator">&gt;</span> s.length<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">case</span> Integer i -<span class="token operator">&gt;</span> i * <span class="token number">2</span><span class="token punctuation">;</span>
   default -<span class="token operator">&gt;</span> -1<span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，case String s 和 case Integer i 就是模式，它们分别用于匹配字符串和整数类型的对象。<br> 类型推断<br> 类型推断是指根据上下文信息，自动推断出某个表达式的类型。在 Pattern Matching for switch 中，我们可以使用 var<br> 关键字来进行类型推断。例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>int result <span class="token operator">=</span> switch <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> String s -<span class="token operator">&gt;</span> s.length<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> Integer i -<span class="token operator">&gt;</span> i * <span class="token number">2</span><span class="token punctuation">;</span>
default -<span class="token operator">&gt;</span> -1<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，var 关键字用于推断 result 的类型为 int。</p><ol start="4"><li>Pattern Matching for switch 的优点</li></ol><p>简化了对变量类型的判断和提取逻辑，使代码更加简洁、清晰。<br> 减少了重复的代码，提高了开发效率。<br> 增强了代码的可读性和可维护性。</p><ol start="5"><li>Pattern Matching for switch 的缺点</li></ol><p>只能用于 switch 语句中，不能直接用于 if-else 结构。<br> 目前只支持基本数据类型和引用类型的模式匹配，不支持其他特殊类型（如枚举、数组等）的模式匹配。</p><ol start="6"><li>Pattern Matching for switch 的使用示例<br> 下面是一个使用 Pattern Matching for switch 的示例代码：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  public static void process<span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  switch <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> String s -<span class="token operator">&gt;</span> System.out.println<span class="token punctuation">(</span><span class="token string">&quot;String: &quot;</span> + s<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> Integer i -<span class="token operator">&gt;</span> System.out.println<span class="token punctuation">(</span><span class="token string">&quot;Integer: &quot;</span> + i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> Double d -<span class="token operator">&gt;</span> System.out.println<span class="token punctuation">(</span><span class="token string">&quot;Double: &quot;</span> + d<span class="token punctuation">)</span><span class="token punctuation">;</span>
  default -<span class="token operator">&gt;</span> System.out.println<span class="token punctuation">(</span><span class="token string">&quot;Unknown type&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，根据传入的对象类型不同，会执行相应的逻辑。</p><ol start="7"><li>Pattern Matching for switch 的使用注意事项</li></ol><p>模式匹配是按照 case 的顺序进行匹配的，因此需要将更具体的模式放在前面。<br> 如果没有匹配到任何模式，则会执行 default 分支的逻辑。<br> 在一个 switch 块内部，每个模式只能出现一次，否则会编译报错。</p><ol start="8"><li>总结<br> Pattern Matching for switch 是 Java 14 中引入的一个新特性，它允许在 switch<br> 语句中使用模式匹配。通过这个特性，我们可以更方便地对变量进行类型判断和提取。它简化了对变量类型的判断和提取逻辑，使代码更加简洁、清晰，并且增强了代码的可读性和可维护性。但需要注意的是，目前只支持基本数据类型和引用类型的模式匹配，不支持其他特殊类型的模式匹配。</li></ol><p>| 442: | <a href="https://openjdk.org/jeps/442" target="_blank" rel="noopener noreferrer">Foreign Function &amp; Memory API (Third Preview)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |</p><ol><li>什么是 Foreign Function &amp; Memory API (Third Preview)?<br> Foreign Function &amp; Memory API 是 Java 平台的一个功能，它允许开发者直接与本地代码进行交互，并且可以在 Java<br> 中操作本地内存。这个功能最初在<br> JDK 14 的时候以 JEP 383 的形式引入了第一次预览版，然后在 JDK 15 中进一步改进并发布了第二次预览版（JEP 393），现在在 JDK<br> 21<br> 中发布了第三次预览版（JEP 442）。</li><li>为什么需要 Foreign Function &amp; Memory API?<br> Foreign Function &amp; Memory API 的出现主要是为了解决以下几个问题：</li></ol><p>与本地代码的无缝集成：有些场景下，我们可能需要调用本地库或者系统级别的函数，例如使用硬件加速、调用底层操作系统的特定功能等。而<br> Foreign Function &amp; Memory API 可以使得 Java 程序能够直接调用本地函数，从而实现与本地代码的无缝集成。<br> 提高性能：通过直接操作本地内存，可以避免数据拷贝和类型转换带来的性能损耗，从而提高程序的执行效率。<br> 扩展现有 Java 库的功能：Foreign Function &amp; Memory API 提供了一种机制，可以将本地库中的函数包装成 Java 接口，从而方便地扩展现有的<br> Java 库的功能。</p><ol start="3"><li>Foreign Function &amp; Memory API 的实现原理<br> Foreign Function &amp; Memory API 的实现主要依赖于以下几个关键技术：</li></ol><p>JNI（Java Native Interface）：JNI 是 Java 平台提供的一种机制，用于在 Java 程序中调用本地代码。Foreign Function &amp; Memory<br> API 利用 JNI 提供的能力，使得 Java 程序可以直接调用本地函数。<br> 内存管理：Foreign Function &amp; Memory API 允许开发者直接操作本地内存，包括分配、释放和读写等操作。这需要对内存进行有效的管理，以确保安全性和可靠性。<br> 类型映射：由于 Java 和本地代码使用不同的数据类型表示数据，因此需要进行类型映射。Foreign Function &amp; Memory API<br> 提供了一套规则和工具，用于将 Java 类型与本地类型进行转换。</p><ol start="4"><li>Foreign Function &amp; Memory API 的优点</li></ol><p>无缝集成：Foreign Function &amp; Memory API 可以使得 Java 程序能够直接调用本地函数，从而实现与本地代码的无缝集成。<br> 高性能：通过直接操作本地内存，避免了数据拷贝和类型转换带来的性能损耗，从而提高程序的执行效率。<br> 灵活性：Foreign Function &amp; Memory API 提供了丰富的功能和灵活的接口，可以满足不同场景下的需求。</p><ol start="5"><li>Foreign Function &amp; Memory API 的缺点</li></ol><p>安全性风险：直接操作本地内存可能会带来一些安全风险，例如内存泄漏、访问非法内存等。因此，在使用 Foreign Function &amp;<br> Memory API 时需要谨慎处理，并遵循相关的安全规范。<br> 复杂性：Foreign Function &amp; Memory API 涉及到与本地代码的交互和内存管理等复杂的问题，对开发者的要求较高，需要具备一定的底层编程知识和经验。</p><ol start="6"><li>Foreign Function &amp; Memory API 的使用示例<br> 以下是一个简单的示例，展示了如何使用 Foreign Function &amp; Memory API 调用本地函数：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">jdk<span class="token punctuation">.</span>incubator<span class="token punctuation">.</span>foreign<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NativeFunctionExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">MemorySegment</span> segment <span class="token operator">=</span> <span class="token class-name">MemorySegment</span><span class="token punctuation">.</span><span class="token function">allocateNative</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">CLinker</span> linker <span class="token operator">=</span> <span class="token class-name">CLinker</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">FunctionDescriptor</span> descriptor <span class="token operator">=</span> <span class="token class-name">FunctionDescriptor</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">CLinker</span><span class="token punctuation">.</span><span class="token constant">C_INT</span><span class="token punctuation">,</span> <span class="token class-name">CLinker</span><span class="token punctuation">.</span><span class="token constant">C_POINTER</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">LibraryLookup</span> lookup <span class="token operator">=</span> <span class="token class-name">LibraryLookup</span><span class="token punctuation">.</span><span class="token function">ofDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Symbol</span> symbol <span class="token operator">=</span> lookup<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">&quot;printf&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">FunctionHandle</span> handle <span class="token operator">=</span> linker<span class="token punctuation">.</span><span class="token function">downcallHandle</span><span class="token punctuation">(</span>symbol<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
            <span class="token class-name">MemoryAccess</span><span class="token punctuation">.</span><span class="token function">setCString</span><span class="token punctuation">(</span>segment<span class="token punctuation">.</span><span class="token function">baseAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> handle<span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span>segment<span class="token punctuation">.</span><span class="token function">baseAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Result: &quot;</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述示例中，我们使用 Foreign Function &amp; Memory API 调用了本地的 printf 函数，并将结果打印出来。</p><ol start="7"><li>Foreign Function &amp; Memory API 的使用注意事项</li></ol><p>在使用 Foreign Function &amp; Memory API 时，需要确保本地函数和库已经正确安装并可用。<br> 对于直接操作本地内存的情况，需要特别注意内存管理和安全性问题，避免出现内存泄漏、访问非法内存等问题。<br> 使用 Foreign Function &amp; Memory API 需要谨慎处理异常，以确保程序的稳定性和可靠性。</p><ol start="8"><li>总结<br> Foreign Function &amp; Memory API 是 Java 平台提供的一种机制，可以使得 Java 程序能够直接调用本地函数，并且可以在 Java<br> 中操作本地内存。它通过 JNI 技术实现与本地代码的无缝集成，并提供了高性能和灵活性。然而，在使用 Foreign Function &amp; Memory<br> API<br> 时需要注意安全性和复杂性等问题，以确保程序的稳定性和可靠性。</li></ol><p>| 443: | <a href="https://openjdk.org/jeps/443" target="_blank" rel="noopener noreferrer">Unnamed Patterns and Variables (Preview)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |</p><ol><li>什么是 Unnamed Patterns and Variables (Preview)?<br> Unnamed Patterns and Variables 是 Java 编程语言的一个新特性，它在 JDK 14 中引入，并在 JDK 15<br> 中作为预览功能继续存在。该特性允许我们使用匿名模式和变量来简化代码并提高可读性。</li><li>为什么需要 Unnamed Patterns and Variables?<br> 在传统的 Java 代码中，当我们需要对某个对象进行模式匹配时，通常需要创建一个临时变量来存储匹配结果。这样会导致代码冗长、可读性差，并且增加了不必要的命名负担。<br> 而 Unnamed Patterns and Variables 的出现正是为了解决这个问题。通过使用匿名模式和变量，我们可以直接在模式匹配表达式中使用，避免了创建临时变量的麻烦，使得代码更加简洁和易于理解。</li><li>Unnamed Patterns and Variables 的实现原理<br> Unnamed Patterns and Variables 的实现原理主要涉及两个方面：匿名模式和匿名变量。<br> 匿名模式<br> 匿名模式是一种特殊的模式，用于表示我们只关心某个值是否满足某个条件，而不关心具体的值是什么。在匿名模式中，我们使用下划线 _<br> 来代替具体的变量名。<br> 例如，我们可以使用匿名模式来判断一个对象是否为 null：<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>obj instanceof String _<span class="token punctuation">)</span> <span class="token punctuation">{</span>
System.out.println<span class="token punctuation">(</span><span class="token string">&quot;obj is a non-null string&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>匿名变量<br> 匿名变量是一种特殊的变量，用于表示我们不需要使用该变量的值。在匿名变量中，我们同样使用下划线 _ 来代替具体的变量名。<br> 例如，在 switch 语句中，我们可以使用匿名变量来忽略某些分支的返回值：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">switch</span><span class="token punctuation">(</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token constant">MONDAY</span><span class="token punctuation">,</span><span class="token constant">TUESDAY</span><span class="token punctuation">,</span><span class="token constant">WEDNESDAY</span><span class="token punctuation">,</span><span class="token constant">THURSDAY</span><span class="token operator">-&gt;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span>

<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Weekday&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">FRIDAY</span><span class="token operator">-&gt;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span>

<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Friday&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token constant">SATURDAY</span><span class="token punctuation">,</span><span class="token constant">SUNDAY</span><span class="token operator">-&gt;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span>

<span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Weekend&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">default</span> <span class="token operator">-&gt;</span><span class="token keyword">throw</span> <span class="token keyword">new</span>

<span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;Invalid day of week: &quot;</span><span class="token operator">+</span>dayOfWeek<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>Unnamed Patterns and Variables 的优点</li></ol><p>简化代码：通过使用匿名模式和变量，可以减少临时变量的创建，使得代码更加简洁。<br> 提高可读性：匿名模式和变量能够直接表达我们关心的条件，避免了命名的繁琐，使得代码更易于理解。</p><ol start="5"><li>Unnamed Patterns and Variables 的缺点<br> 由于 Unnamed Patterns and Variables 目前仍处于预览阶段，因此存在以下一些限制和潜在问题：</li></ol><p>兼容性问题：由于该特性是在 JDK 14 中引入的，并且仍处于预览阶段，因此可能存在与旧版本 Java 不兼容的问题。<br> 语法限制：匿名模式和变量只能用于某些特定的上下文中，不能在所有地方使用。例如，在 lambda 表达式、方法引用等场景中暂时还无法使用。</p><ol start="6"><li>Unnamed Patterns and Variables 的使用示例<br> 以下是一个使用匿名模式和变量的示例代码，用于判断一个对象是否为非空字符串：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">String</span> _<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;obj is a non-null string&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>Unnamed Patterns and Variables 的使用注意事项<br> 在使用 Unnamed Patterns and Variables 时，需要注意以下几点：</li></ol><p>匿名模式和变量只能用于表示我们不关心具体值的情况，如果需要获取具体的值，则应该使用普通的命名模式和变量。<br> 在一些特殊的上下文中，如 lambda 表达式、方法引用等，目前还无法使用匿名模式和变量。</p><ol start="8"><li>总结<br> Unnamed Patterns and Variables 是 Java<br> 编程语言的一个新特性，它通过引入匿名模式和变量来简化代码并提高可读性。虽然该特性目前仍处于预览阶段，并存在一些限制和潜在问题，但它为我们编写更简洁、易读的代码提供了一种新的方式。</li></ol><p>| 444: | <a href="https://openjdk.org/jeps/444" target="_blank" rel="noopener noreferrer">Virtual Threads<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |</p><ol><li>什么是 Virtual Threads?<br> Virtual Threads（虚拟线程）是 Java 平台的一项新功能，它旨在改进 Java 中的并发编程模型。传统上，Java<br> 使用基于操作系统线程的并发模型，每个线程都需要分配一个操作系统线程来执行。而 Virtual<br> Threads 则提供了一种更高效、更轻量级的线程模型。</li><li>为什么需要 Virtual Threads?<br> 在传统的基于操作系统线程的并发模型中，创建和销毁线程以及在线程之间切换的开销很大。这限制了 Java<br> 应用程序在处理大规模并发时的性能和扩展性。此外，由于操作系统线程的数量有限，当应用程序需要创建大量线程时，可能会导致资源耗尽或者性能下降。<br> Virtual<br> Threads 的出现解决了这些问题。它通过引入一种轻量级的线程模型，可以在 Java 应用程序中创建数百万甚至数十亿个线程，而不会受到操作系统线程数量的限制。这使得<br> Java 应用程序能够更好地适应大规模并发场景，并提供更高的性能和可伸缩性。</li><li>Virtual Threads 的实现原理<br> Virtual Threads 的实现依赖于 Java 虚拟机（JVM）的协作调度器和 Fork/Join 框架。它通过将多个 Virtual<br> Threads 映射到少量的操作系统线程上来实现高效的并发执行。<br> 具体而言，当一个 Java 应用程序创建一个 Virtual<br> Thread 时，JVM 会为其分配一个虚拟线程（也称为轻量级线程）。这些虚拟线程由协作调度器管理，并在需要时与操作系统线程进行绑定。协作调度器负责决定哪个虚拟线程可以运行以及何时切换虚拟线程。<br> Fork/Join 框架是 Virtual Threads 的另一个关键组件。它提供了一种任务并行编程模型，允许开发人员将任务分解成更小的子任务，并使用工作窃取算法来实现负载均衡。Virtual<br> Threads 利用 Fork/Join 框架的能力，在不同的虚拟线程之间自动地、透明地进行任务划分和调度。</li><li>Virtual Threads 的优点</li></ol><p>更高的性能：Virtual Threads 减少了线程创建和销毁的开销，同时避免了操作系统线程数量的限制，从而提供更高的性能。<br> 更好的可伸缩性：由于 Virtual Threads 可以创建数百万甚至数十亿个线程，因此 Java 应用程序可以更好地适应大规模并发场景，并具有更好的可伸缩性。<br> 更低的资源消耗：相比于操作系统线程，Virtual Threads 是轻量级的，占用更少的内存和 CPU 资源。</p><ol start="5"><li>Virtual Threads 的缺点<br> 虽然 Virtual Threads 带来了许多优势，但也存在一些潜在的缺点：</li></ol><p>学习成本较高：使用 Virtual Threads 需要对并发编程模型有一定的理解，并且需要适应新的 API 和开发范式。<br> 可能引入新的问题：由于 Virtual Threads 是一个相对较新的功能，可能会存在一些未知的问题或者不稳定性。</p><ol start="6"><li>Virtual Threads 的使用示例<br> 下面是一个简单的使用 Virtual Threads 的示例代码：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Executors</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">ThreadPoolExecutor</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VirtualThreadsExample</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">)</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newVirtualThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">int</span> taskId <span class="token operator">=</span> i<span class="token punctuation">;</span>
          executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
              <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Task &quot;</span> <span class="token operator">+</span> taskId <span class="token operator">+</span> <span class="token string">&quot; is running on virtual thread: &quot;</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述示例中，我们使用Executors.newVirtualThreadExecutor()方法创建了一个ThreadPoolExecutor实例，该实例可以执行 Virtual<br> Threads。然后，我们通过调用execute()方法提交了一系列任务，每个任务都会打印当前运行的虚拟线程的名称。</p><ol start="7"><li>Virtual Threads 的使用注意事项<br> 在使用 Virtual Threads 时，需要注意以下几点：</li></ol><p>虽然 Virtual Threads 可以创建大量线程，但过多的线程仍可能导致性能下降或资源耗尽。因此，在设计应用程序时，仍需合理控制并发度。<br> 使用 Virtual Threads 时，需要遵循良好的并发编程实践，如避免共享可变状态、使用适当的同步机制等，以确保线程安全性和正确性。<br> 在迁移现有代码到使用 Virtual Threads 时，需要进行一定的重构和调整，以适应新的 API 和开发范式。</p><ol start="8"><li>总结<br> Virtual Threads 是 Java 平台的一项新功能，旨在改进 Java 中的并发编程模型。它通过引入轻量级的虚拟线程，并利用协作调度器和<br> Fork/Join 框架来提供高效的并发执行。Virtual<br> Threads 具有更高的性能、更好的可伸缩性和较低的资源消耗，但也需要学习成本较高，并且可能存在一些潜在的问题。在使用 Virtual<br> Threads 时，需要注意合理控制并发度、遵循并发编程实践，并进行必要的重构和调整。</li></ol><p>| 445: | <a href="https://openjdk.org/jeps/445" target="_blank" rel="noopener noreferrer">Unnamed Classes and Instance Main Methods (Preview)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>|</p><ol><li>什么是 Unnamed Classes and Instance Main Methods (Preview)?<br> &quot;Unnamed Classes and Instance Main Methods&quot; 是一个 Java 编程语言的新特性，它在 JDK 14 中引入，并在 JDK 15<br> 中成为预览功能。该特性允许我们在类中定义匿名类和实例主方法。<br> 在传统的 Java 编程中，我们只能在顶级类或静态内部类中定义 main 方法作为程序的入口点。而使用 &quot;Unnamed Classes and<br> Instance<br> Main Methods&quot; 特性后，我们可以在任何类的实例中定义 main 方法，从而使得程序的入口点更加灵活。</li><li>为什么需要 Unnamed Classes and Instance Main Methods?<br> 传统的 Java 程序必须将 main<br> 方法定义在顶级类或静态内部类中，这限制了程序的结构和组织方式。有时候，我们可能希望将多个相关的逻辑封装在同一个类的实例中，以提高代码的可读性和可维护性。而 &quot;<br> Unnamed Classes and Instance Main Methods&quot; 特性正是为了满足这种需求而引入的。<br> 通过在类的实例中定义 main 方法，我们可以更好地组织和管理程序的逻辑，减少顶级类和静态内部类的数量，使代码更加清晰和易于理解。</li><li>Unnamed Classes and Instance Main Methods 的实现原理<br> &quot;Unnamed Classes and Instance Main Methods&quot; 特性的实现原理涉及到两个方面：匿名类和实例主方法。<br> 3.1 匿名类<br> 在 Java 中，我们可以使用匿名类来创建一个没有显式名称的类。匿名类通常用于创建临时的、只需要一次使用的类对象。它们可以继承自某个类或实现某个接口，并重写其中的方法。<br> 匿名类的语法如下：<br> java复制代码new 父类构造器(参数列表) {<br> // 匿名类的成员变量和方法定义<br> }</li></ol><p>3.2 实例主方法<br> 传统的 Java 程序入口点是通过静态 main 方法来定义的，而 &quot;Unnamed Classes and Instance Main Methods&quot; 特性允许我们在类的实例中定义<br> main 方法。<br> 实例主方法的语法如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 主方法的代码逻辑</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>Unnamed Classes and Instance Main Methods 的优点</li></ol><p>灵活性：通过在类的实例中定义 main 方法，程序的入口点更加灵活，可以根据需求将多个相关的逻辑封装在同一个类的实例中。<br> 可读性：将相关的逻辑组织在同一个类的实例中，使得代码更加清晰和易于理解。<br> 可维护性：减少顶级类和静态内部类的数量，简化代码结构，提高代码的可维护性。</p><ol start="5"><li>Unnamed Classes and Instance Main Methods 的缺点</li></ol><p>语法复杂：匿名类和实例主方法的语法相对传统的 main 方法更加复杂，需要额外的学习成本。<br> 可读性降低：如果滥用该特性，将多个逻辑封装在同一个类的实例中可能会导致代码可读性下降。</p><ol start="6"><li>Unnamed Classes and Instance Main Methods 的使用示例<br> 下面是一个使用 &quot;Unnamed Classes and Instance Main Methods&quot; 特性的示例：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Example</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">new</span> <span class="token class-name">Example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">main</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>在上述示例中，我们定义了一个名为 Example 的类，并在其中创建了一个实例。通过调用实例的 main<br> 方法，程序的入口点被指定为该实例的 main 方法。</p><ol start="7"><li>Unnamed Classes and Instance Main Methods 的使用注意事项</li></ol><p>在使用 &quot;Unnamed Classes and Instance Main Methods&quot; 特性时，需要确保每个类的实例只有一个 main 方法，否则编译器将无法确定程序的入口点。<br> 匿名类和实例主方法的语法较为复杂，需要仔细理解并遵循正确的语法规则。<br> 虽然 &quot;Unnamed Classes and Instance Main Methods&quot; 特性在 JDK 15 中成为预览功能，但仍然存在一些潜在的问题和限制。在使用时需要注意这些问题，并及时反馈给开发团队。</p><ol start="8"><li>总结<br> &quot;Unnamed Classes and Instance Main Methods&quot; 是 Java<br> 编程语言的一个新特性，它允许我们在类的实例中定义匿名类和实例主方法。通过该特性，我们可以更灵活地组织程序的逻辑，提高代码的可读性和可维护性。然而，使用该特性需要注意语法复杂性和可读性降低的问题，并遵循正确的使用方式。</li></ol><p>| 446: | <a href="https://openjdk.org/jeps/446" target="_blank" rel="noopener noreferrer">Scoped Values (Preview)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>|</p><ol><li>什么是 Scoped Values (Preview)?<br> Scoped Values (Preview) 是 Java 平台的一个新特性，它在 JDK 17 中引入。该特性旨在提供一种机制，用于在代码块级别上设置和使用临时变量。</li><li>为什么需要 Scoped Values (Preview)?<br> 在传统的 Java 编程中，我们通常会将变量声明在方法或类的作用域内，并且这些变量的生命周期与其所在的作用域相同。然而，在某些情况下，我们可能希望在更小的范围内定义临时变量，以便更好地控制其可见性和生命周期。<br> Scoped Values (Preview) 提供了一种简洁、安全的方式来定义和使用临时变量，使得代码更加清晰易读，并且可以减少不必要的命名冲突和资源泄漏问题。</li><li>Scoped Values (Preview) 的实现原理?<br> Scoped Values (Preview) 的实现基于 Java 语言规范中的局部变量类型推断（Local Variable Type Inference）机制。通过使用 var<br> 关键字，我们可以在代码块内部声明临时变量，并根据初始化表达式的类型进行类型推断。<br> 例如，以下示例展示了如何使用 Scoped Values (Preview) 声明和使用临时变量：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">exampleMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 使用 Scoped Values (Preview) 声明临时变量</span>
<span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// 在代码块内部使用临时变量</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>在上述示例中，我们使用 Scoped Values (Preview) 声明了一个名为 message 的临时变量，并将其初始化为字符串 &quot;Hello, World!&quot;<br> 。然后，在 if 语句的代码块内部，我们可以直接使用该临时变量。</p><ol start="4"><li>Scoped Values (Preview) 的优点</li></ol><p>简洁性：Scoped Values (Preview) 提供了一种更简洁的方式来声明和使用临时变量，减少了冗余的代码。<br> 可读性：通过在代码块级别上定义临时变量，使得代码更加清晰易读，提高了代码的可维护性。<br> 类型安全：Scoped Values (Preview) 基于 Java 语言规范中的局部变量类型推断机制，确保了变量的类型安全性。</p><ol start="5"><li>Scoped Values (Preview) 的缺点<br> 尽管 Scoped Values (Preview) 提供了许多优点，但也存在一些潜在的缺点：</li></ol><p>兼容性问题：由于 Scoped Values (Preview) 是 JDK 17 中引入的新特性，因此在较旧版本的 Java 中无法使用。<br> 学习成本：对于不熟悉局部变量类型推断机制的开发人员来说，可能需要一些时间来适应 Scoped Values (Preview) 的使用方式。</p><ol start="6"><li>Scoped Values (Preview) 的使用示例<br> 以下是一个使用 Scoped Values (Preview) 的简单示例：<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><p>在上述示例中，我们使用 Scoped Values (Preview) 声明了一个名为 message 的临时变量，并将其初始化为字符串 &quot;Hello, World!&quot;<br> 。然后，我们通过调用 System.out.println 方法打印该临时变量的值。</p><ol start="7"><li>Scoped Values (Preview) 的使用注意事项<br> 在使用 Scoped Values (Preview) 时，需要注意以下几点：</li></ol><p>作用域限制：Scoped Values (Preview) 声明的临时变量仅在当前代码块内部可见，超出该代码块范围后将无法访问。<br> 类型推断：由于 Scoped Values (Preview) 是基于局部变量类型推断机制实现的，因此必须确保初始化表达式具有明确的类型信息，以便进行正确的类型推断。<br> 命名冲突：当在同一代码块内使用多个 Scoped Values (Preview) 声明临时变量时，需要避免命名冲突，以免引起混淆和错误。</p><ol start="8"><li>总结<br> Scoped Values (Preview) 是 Java 平台的一个新特性，它提供了一种在代码块级别上设置和使用临时变量的机制。通过使用 var<br> 关键字，我们可以在代码块内部声明临时变量，并根据初始化表达式的类型进行类型推断。Scoped Values (Preview)<br> 的优点包括简洁性、可读性和类型安全性，但也存在兼容性问题和学习成本。在使用 Scoped Values (Preview)<br> 时，需要注意作用域限制、类型推断和命名冲突等注意事项。</li></ol><p>| 448: | <a href="https://openjdk.org/jeps/448" target="_blank" rel="noopener noreferrer">Vector API (Sixth Incubator)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>|</p><ol><li>什么是 Vector API (Sixth Incubator)?<br> Vector API (Sixth Incubator) 是 Java 平台的一个项目，旨在提供一种简单且高效的方式来执行向量化计算。它引入了新的类和接口，以支持使用<br> SIMD（Single Instruction, Multiple Data）指令集进行并行计算。</li><li>为什么需要 Vector API (Sixth Incubator)?<br> 在许多应用程序中，存在大量的数据并行计算任务，例如图像处理、科学计算和机器学习等领域。传统的 Java<br> 编程模型无法充分利用现代硬件的并行计算能力，导致性能低下。而 Vector API (Sixth Incubator) 的目标就是通过向量化计算来提高这些应用程序的性能。</li><li>Vector API (Sixth Incubator) 的实现原理?<br> Vector API (Sixth Incubator) 基于 SIMD 指令集，即单指令多数据流指令集。SIMD 指令集可以同时对多个数据元素执行相同的操作，从而实现并行计算。Vector<br> API (Sixth Incubator) 提供了一组新的类和接口，使开发人员能够直接编写基于 SIMD 指令集的代码。<br> 具体来说，Vector API (Sixth Incubator) 引入了 java.util.vector 包，其中包含了一些新的类和接口，如 Vector、FloatVector<br> 和 IntVector 等。这些类提供了一组向量化操作方法，例如加法、减法、乘法等，以及对应的掩码操作。<br> 在底层实现上，Vector API (Sixth Incubator) 使用了特定硬件平台的 SIMD 指令集来执行向量化计算。具体实现细节会依赖于不同的硬件架构和操作系统。</li><li>Vector API (Sixth Incubator) 的优点</li></ol><p>提高性能：通过利用 SIMD 指令集进行并行计算，可以显著提高应用程序的性能。<br> 简化编程模型：Vector API (Sixth Incubator) 提供了一组简单易用的类和接口，使开发人员能够直接编写基于 SIMD 指令集的代码，而无需手动优化。</p><ol start="5"><li>Vector API (Sixth Incubator) 的缺点</li></ol><p>平台限制：Vector API (Sixth Incubator) 的实现依赖于特定的硬件平台和操作系统，因此在不同的平台上可能存在兼容性问题。<br> 学习成本：使用 Vector API (Sixth Incubator) 需要学习新的类和接口，并理解 SIMD 指令集的工作原理，对于一些开发人员来说可能需要花费一定的时间和精力。</p><ol start="6"><li>Vector API (Sixth Incubator) 的使用示例<br> 下面是一个简单的使用 Vector API (Sixth Incubator) 进行向量化计算的示例：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>vector<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VectorExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建两个向量对象</span>
        <span class="token class-name">FloatVector</span> a <span class="token operator">=</span> <span class="token class-name">FloatVector</span><span class="token punctuation">.</span><span class="token function">broadcast</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">2.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FloatVector</span> b <span class="token operator">=</span> <span class="token class-name">FloatVector</span><span class="token punctuation">.</span><span class="token function">broadcast</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">3.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行向量化加法操作</span>
        <span class="token class-name">FloatVector</span> result <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出结果</span>
        <span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">float</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">intoArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">float</span> value <span class="token operator">:</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们创建了两个长度为 8 的浮点数向量，并执行了向量化的加法操作。最后将结果输出到数组中并打印出来。</p><ol start="7"><li>Vector API (Sixth Incubator) 的使用注意事项</li></ol><p>硬件兼容性：由于 Vector API (Sixth Incubator) 的实现依赖于特定的硬件平台和操作系统，因此在使用之前需要确保目标平台支持<br> SIMD 指令集。<br> 性能优化：虽然 Vector API (Sixth Incubator) 可以提高应用程序的性能，但要获得最佳性能还需要进行适当的优化。例如，避免频繁的向量化操作和数据拷贝等。</p><ol start="8"><li>总结<br> Vector API (Sixth Incubator) 是 Java 平台的一个项目，旨在提供一种简单且高效的方式来执行向量化计算。它基于 SIMD<br> 指令集，并通过引入新的类和接口来支持并行计算。使用 Vector API (Sixth Incubator) 可以提高应用程序的性能，但需要注意硬件兼容性和适当的性能优化。</li></ol><p>| 449: | <a href="https://openjdk.org/jeps/449" target="_blank" rel="noopener noreferrer">Deprecate the Windows 32-bit x86 Port for Removal<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |<br> 名字太长了。。后面简称 449</p><ol><li>什么是 JEP 449?<br> JEP 449（Java Enhancement Proposal 449）是一个针对 OpenJDK 的提案，旨在废弃并最终移除 Windows 32 位 x86 平台上的 Java<br> 支持。</li><li>为什么需要废弃 Windows 32 位 x86 平台上的 Java 支持？<br> 主要有以下几个原因：</li></ol><p>过时的硬件和操作系统：Windows 32 位 x86 平台已经逐渐被淘汰，现代计算机普遍采用 64 位架构。同时，大多数新版本的 Windows<br> 操作系统也只提供了 64 位版本。<br> 性能限制：32 位架构限制了可寻址内存空间的大小，导致无法充分利用现代计算机的资源。而 64 位架构可以提供更大的内存地址空间，从而提高应用程序的性能和扩展性。<br> 安全问题：32 位架构存在一些安全漏洞和限制，例如缓冲区溢出等。而 64 位架构通过引入更多的保护机制来增加应用程序的安全性。</p><p>基于以上原因，废弃 Windows 32 位 x86 平台上的 Java 支持是合理且必要的。</p><ol start="3"><li>JEP 449 的实现原理<br> JEP 449 的实现原理涉及到编译器、虚拟机和库等多个方面的改动。</li></ol><p>编译器层面：废弃 32 位 x86 平台上的 Java 支持需要对编译器进行修改，禁止生成 32 位 x86 架构的目标代码。<br> 虚拟机层面：虚拟机需要对内存管理、垃圾回收等进行调整，以适应 64 位架构的特性。同时，还需要更新与操作系统交互的部分代码，确保在<br> 64 位环境下正常运行。<br> 库层面：一些与硬件相关的库可能需要重新编写或者替换为 64 位版本，以充分利用 64 位架构的优势。</p><p>具体实现细节可以参考 JEP 449 提案中的详细说明。</p><ol start="4"><li>JEP 449 的优点</li></ol><p>性能提升：64 位架构可以提供更大的内存地址空间，从而提高应用程序的性能和扩展性。<br> 安全增强：64 位架构引入了更多的保护机制，提高了应用程序的安全性。<br> 与现代计算机趋势相符：Windows 32 位 x86 平台已经逐渐被淘汰，废弃该平台上的 Java 支持是与时俱进的举措。</p><ol start="5"><li>JEP 449 的缺点</li></ol><p>向后兼容性问题：废弃 Windows 32 位 x86 平台上的 Java 支持可能导致一些现有的应用程序无法在该平台上运行。这需要开发人员进行相应的迁移和调整。<br> **对于仍然使用 32 位硬件和操作系统的用户而言，将无法继续获得新版本的 Java 更新和功能改进。</p><ol start="6"><li>JEP 449 的使用示例<br> JEP 449 是一个 OpenJDK 的提案，它主要影响到 OpenJDK 的开发者和 Windows 32 位 x86 平台上的 Java 用户。对于开发者来说，他们需要根据<br> JEP<br> 449 的实施情况，适时地迁移和调整自己的应用程序代码。对于 Windows<br> 32 位 x86 平台上的 Java 用户来说，他们需要考虑升级到 64 位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</li><li>JEP 449 的使用注意事项</li></ol><p>开发者需要及时关注 JEP 449 的实施情况，并根据需要进行相应的迁移和调整。<br> Windows 32 位 x86 平台上的 Java 用户需要考虑升级到 64 位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</p><ol start="8"><li>总结<br> JEP 449 旨在废弃并最终移除 Windows<br> 32 位 x86 平台上的 Java 支持。这是基于该平台已经逐渐被淘汰、性能限制和安全问题等原因做出的合理举措。废弃该平台上的 Java<br> 支持可以提高应用程序的性能和安全性，并与现代计算机趋势相符。开发者需要及时关注 JEP<br> 449 的实施情况，并根据需要进行相应的迁移和调整。Windows 32 位 x86 平台上的 Java 用户需要考虑升级到 64<br> 位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</li></ol><p>| 451: |<a href="https://openjdk.org/jeps/451" target="_blank" rel="noopener noreferrer">Prepare to Disallow the Dynamic Loading of Agents<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |</p><ol><li>什么是动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of Agents）？<br> 动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of<br> Agents）是一个 Java 增强提案，其目标是在 JVM 中禁止动态加载代理。代理是一种能够修改或监视应用程序行为的机制，它可以通过字节码注入来实现。</li><li>为什么需要动态加载代理禁用准备？<br> 动态加载代理允许开发人员在运行时修改和监视 Java<br> 应用程序的行为。虽然这对于调试和性能分析等方面非常有用，但也存在潜在的安全风险。恶意代码可能会利用动态加载代理的功能来执行恶意操作，例如窃取敏感信息、篡改数据等。<br> 因此，为了加强 Java 应用程序的安全性，限制动态加载代理的使用是很有必要的。</li><li>动态加载代理禁用准备的实现原理<br> 动态加载代理禁用准备的实现涉及到以下几个方面：<br> 3.1 修改 ClassLoader<br> 该提案建议修改 Java 虚拟机的类加载器，以阻止动态加载代理。具体而言，将在java.lang.ClassLoader<br> 类中添加一个新的方法boolean disallowDynamicAgentLoading()，默认返回false。当该方法被调用时，将返回true，表示禁止动态加载代理。<br> 3.2 修改 Instrumentation API<br> 为了支持 ClassLoader 的修改，还需要对 Java 虚拟机的 Instrumentation<br> API 进行相应的更改。具体而言，将在java.lang.instrument.Instrumentation<br> 接口中添加一个新的方法boolean isDynamicAgentLoadingAllowed()，默认返回true。当该方法返回false时，表示禁止动态加载代理。<br> 3.3 更新安全管理器<br> 此外，还建议更新 Java 虚拟机的安全管理器（SecurityManager），以允许检查是否允许动态加载代理。这样可以通过安全策略来控制哪些代码可以使用动态加载代理功能。</li><li>动态加载代理禁用准备的优点</li></ol><p>提高 Java 应用程序的安全性：禁止动态加载代理可以防止恶意代码利用其功能执行潜在的危险操作。<br> 简化安全配置：通过更新安全管理器和类加载器，可以更方便地控制动态加载代理的使用权限，简化安全配置过程。</p><ol start="5"><li>动态加载代理禁用准备的缺点</li></ol><p>可能影响现有代码：如果现有代码依赖于动态加载代理的功能，那么禁用它可能会导致这些代码无法正常工作。因此，在应用该增强提案之前，需要仔细评估现有代码的依赖关系。</p><ol start="6"><li>动态加载代理禁用准备的使用示例<br> 以下是一个简单的示例，展示了如何使用动态加载代理禁用准备：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>instrument<span class="token punctuation">.</span></span><span class="token class-name">Instrumentation</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentLoader</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">premain</span><span class="token punctuation">(</span><span class="token class-name">String</span> agentArgs<span class="token punctuation">,</span> <span class="token class-name">Instrumentation</span> inst<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 禁止动态加载代理</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>inst<span class="token punctuation">.</span><span class="token function">isDynamicAgentLoadingAllowed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span><span class="token punctuation">(</span><span class="token string">&quot;Dynamic loading of agents is not allowed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token comment">// 其他初始化操作...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，premain方法是 Java 代理的入口点。通过调用isDynamicAgentLoadingAllowed()方法，可以检查是否允许动态加载代理。如果不允许，则抛出安全异常。</p><ol start="7"><li>动态加载代理禁用准备的使用注意事项</li></ol><p>在使用动态加载代理禁用准备之前，需要仔细评估现有代码是否依赖于动态加载代理的功能。<br> 需要更新相关的类加载器和安全管理器来支持禁止动态加载代理的功能。<br> 使用动态加载代理禁用准备时，需要确保应用程序的安全策略能够正确地控制动态加载代理的使用权限。</p><ol start="8"><li>总结<br> 动态加载代理禁用准备是一个 Java 增强提案，旨在禁止动态加载代理以提高应用程序的安全性。它通过修改类加载器、Instrumentation<br> API 和安全管理器来实现禁止动态加载代理的功能。尽管这样做可以增加应用程序的安全性，但也可能影响依赖于动态加载代理的现有代码。因此，在使用该功能之前需要仔细评估现有代码的依赖关系。</li></ol><p>| 452: | <a href="https://openjdk.org/jeps/452" target="_blank" rel="noopener noreferrer">Key Encapsulation Mechanism API<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |</p><ol><li>什么是 Key Encapsulation Mechanism API?<br> Key Encapsulation Mechanism (KEM) API 是一个 Java<br> API，用于支持密钥封装机制。密钥封装是一种加密技术，它将一个对称密钥（也称为会话密钥）与公钥结合使用，以便在不直接暴露私钥的情况下安全地传输密钥。<br> KEM API 提供了一组方法和类，用于生成、封装和解封装密钥。它可以与现有的密码学算法和协议集成，提供更高级别的密钥管理功能。</li><li>为什么需要 Key Encapsulation Mechanism API?<br> 在传统的密钥交换过程中，通常需要事先共享或分发密钥。这可能存在许多安全风险，例如密钥泄露、中间人攻击等。而密钥封装机制通过使用公钥进行密钥交换，避免了这些问题。<br> Key Encapsulation Mechanism API 的出现使得开发者能够更方便地实现密钥封装机制，并提供了更高级别的密钥管理功能。它简化了密钥生成、封装和解封装的过程，同时保证了安全性和可靠性。</li><li>Key Encapsulation Mechanism API 的实现原理<br> Key Encapsulation Mechanism API 的实现原理基于非对称加密算法和密钥封装机制。它使用公钥进行密钥交换，并通过将会话密钥封装在一个安全的密文中，以确保密钥的安全传输。<br> 具体实现过程如下：</li></ol><p>生成一对公私钥对。<br> 使用公钥进行密钥封装，生成一个密文。<br> 将密文发送给接收方。<br> 接收方使用私钥解封装密文，得到会话密钥。<br> 双方可以使用会话密钥进行加密通信。</p><ol start="4"><li>Key Encapsulation Mechanism API 的优点</li></ol><p>安全性高：Key Encapsulation Mechanism API 使用了非对称加密算法和密钥封装机制，能够提供较高的安全性，避免了密钥泄露和中间人攻击等问题。<br> 易于使用：API 提供了简单易用的方法和类，开发者可以轻松地生成、封装和解封装密钥，无需深入了解底层算法和协议。<br> 灵活性强：API 可以与现有的密码学算法和协议集成，提供更高级别的密钥管理功能，满足不同场景的需求。</p><ol start="5"><li>Key Encapsulation Mechanism API 的缺点</li></ol><p>依赖于非对称加密算法：Key Encapsulation Mechanism API 的实现依赖于非对称加密算法，这些算法可能存在性能上的瓶颈和限制。<br> 需要保护私钥的安全：由于使用了非对称加密算法，私钥的安全至关重要。开发者需要采取措施来保护私钥的机密性和完整性。</p><ol start="6"><li>Key Encapsulation Mechanism API 的使用示例<br> 下面是一个简单的使用示例，演示了如何使用 Key Encapsulation Mechanism API 进行密钥封装和解封装：</li></ol><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>   <span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">KeyPair</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">KeyPairGenerator</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>security<span class="token punctuation">.</span></span><span class="token class-name">KeyAgreement</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>crypto<span class="token punctuation">.</span></span><span class="token class-name">Cipher</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KEMExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
<span class="token comment">// 生成公私钥对</span>
        <span class="token class-name">KeyPairGenerator</span> keyPairGenerator <span class="token operator">=</span> <span class="token class-name">KeyPairGenerator</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">&quot;RSA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">KeyPair</span> keyPair <span class="token operator">=</span> keyPairGenerator<span class="token punctuation">.</span><span class="token function">generateKeyPair</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建 KeyAgreement 对象</span>
        <span class="token class-name">KeyAgreement</span> keyAgreement <span class="token operator">=</span> <span class="token class-name">KeyAgreement</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">&quot;DH&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        keyAgreement<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>keyPair<span class="token punctuation">.</span><span class="token function">getPrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 执行密钥协商过程</span>
        keyAgreement<span class="token punctuation">.</span><span class="token function">doPhase</span><span class="token punctuation">(</span>keyPair<span class="token punctuation">.</span><span class="token function">getPublic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 生成会话密钥</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sharedSecret <span class="token operator">=</span> keyAgreement<span class="token punctuation">.</span><span class="token function">generateSecret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 封装会话密钥</span>
        <span class="token class-name">Cipher</span> cipher <span class="token operator">=</span> <span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token string">&quot;AES&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token constant">WRAP_MODE</span><span class="token punctuation">,</span> keyPair<span class="token punctuation">.</span><span class="token function">getPublic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> wrappedKey <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>sharedSecret<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 解封装会话密钥</span>
        cipher<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token constant">UNWRAP_MODE</span><span class="token punctuation">,</span> keyPair<span class="token punctuation">.</span><span class="token function">getPrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> unwrappedKey <span class="token operator">=</span> cipher<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span>wrappedKey<span class="token punctuation">,</span> <span class="token string">&quot;AES&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Cipher</span><span class="token punctuation">.</span><span class="token constant">SECRET_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 输出结果</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Shared Secret: &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>sharedSecret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Unwrapped Key: &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>unwrappedKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>Key Encapsulation Mechanism API 的使用注意事项</li></ol><p>开发者需要选择合适的非对称加密算法和密钥封装机制，根据具体需求进行配置。<br> 私钥的安全至关重要，开发者应该采取措施来保护私钥的机密性和完整性。<br> 密钥封装过程中生成的密文需要通过安全信道传输，以确保密钥的安全性。</p><ol start="8"><li>总结<br> Key Encapsulation Mechanism API 是一个用于支持密钥封装机制的 Java<br> API。它提供了一组方法和类，用于生成、封装和解封装密钥。通过使用公钥进行密钥交换，避免了传统密钥交换方式中存在的安全风险。API<br> 的实现原理基于非对称加密算法和密钥封装机制，能够提供较高的安全性和灵活性。开发者可以轻松地使用 API<br> 进行密钥封装和解封装操作，并与现有的密码学算法和协议集成，满足不同场景的需求。然而，API 的使用需要注意私钥的安全性和密文的传输安全。</li></ol><p>| 453: | <a href="https://openjdk.org/jeps/453" target="_blank" rel="noopener noreferrer">Structured Concurrency (Preview)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> |<br> 什么是结构化并发（Structured Concurrency）？<br> 结构化并发是一种用于简化并发编程的 API。它将在不同线程中运行的相关任务组视为一个单独的工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。<br> 为什么需要结构化并发？<br> 传统的并发编程模型，如ExecutorService<br> API，由于其无限制的并发模式，引入了复杂性和风险。这些模型没有强制执行或跟踪任务和子任务之间的关系，使得管理和观察并发任务变得困难。结构化并发模型认为任务结构应该反映代码结构，在单线程代码中，执行总是强制实施任务和子任务的层次结构，每个子任务的生命周期相对于其他子任务受到代码的语法块结构的控制。<br> 结构化并发旨在消除与并发编程相关的常见风险，例如线程泄漏和取消延迟，并增强并发代码的可观察性。<br> 结构化并发的实现原理<br> 结构化并发通过引入新的 API 来实现，其中最重要的类是StructuredTaskScope。StructuredTaskScope<br> 封装了一组相关的任务，这些任务应该一起完成，如果任何子任务失败，则会取消剩余的子任务。<br> 在结构化并发中，使用StructuredTaskScope<br> 创建一个作用域，在该作用域内可以派生出多个子任务。这些子任务将被视为整体，并且它们之间存在依赖关系。当所有子任务完成后，可以对它们进行处理，例如获取结果或抛出异常。<br> 结构化并发的优点</p><p>简化并发编程：结构化并发提供了一种更简单、更直观的方式来处理并发任务。<br> 错误处理和取消操作：通过将相关任务组合成一个单元，结构化并发使错误处理和取消操作更加容易和可靠。<br> 提高可靠性：结构化并发模型消除了常见的风险，如线程泄漏和取消延迟，从而提高了并发代码的可靠性。<br> 增强可观察性：结构化并发模型使得观察并发任务的执行状态变得更加方便。</p><p>结构化并发的缺点</p><p>预览功能：目前，结构化并发仍处于预览阶段，需要启用预览功能才能使用。</p><p>结构化并发的使用示例<br> 下面是一个使用结构化并发的示例代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token class-name">Response</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StructuredTaskScope<span class="token punctuation">.</span>ShutdownOnFailure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> user <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">findUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Supplier</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> order <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token function">fetchOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        scope<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">throwIfFailed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Response</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> order<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了一个新的StructuredTaskScope作用域，并使用它派生了两个子任务：一个执行findUser()<br> 方法，另一个执行fetchOrder()方法。一旦两个子任务都完成，就可以使用它们的结果创建一个新的Response对象。<br> 结构化并发的使用注意事项</p><p>结构化并发是一个预览功能，默认情况下被禁用。要使用StructuredTaskScope API，开发人员必须启用预览功能来编译代码。<br> 使用结构化并发时，通常不直接使用StructuredTaskScope<br> 类，而是使用实现关闭策略的两个子类之一。这些子类分别是ShutdownOnFailure和ShutdownOnSuccess，支持当第一个子任务失败或成功时关闭作用域的模式。<br> 运行结构化并发程序时，需要使用--enable-preview选项启用预览功能。</p><p>总结<br> 结构化并发是一种用于简化并发编程的 API，它将相关任务组合成一个单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。通过引入StructuredTaskScope<br> 类和相关的子类，结构化并发提供了一种更简单、更直观的方式来处理并发任务。然而，需要注意的是，结构化并发目前仍处于预览阶段，并且需要启用预览功能才能使用。<br> JDK 21 将是大多数供应商的长期支持 （LTS） 版本。有关自上一个 LTS 版本 JDK 17 以来集成的 JEP<br> 的完整列表，请参阅 here.<br> Schedule</p><table><thead><tr><th>发布时间</th><th>发布内容</th></tr></thead><tbody><tr><td>2023/06/08</td><td><a href="https://openjdk.org/jeps/3#rdp-1" target="_blank" rel="noopener noreferrer">第一阶段缓慢降级（从主分支派生）<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td></tr><tr><td>2023/07/20</td><td><a href="https://openjdk.org/jeps/3#rdp-2" target="_blank" rel="noopener noreferrer">第二阶段缓慢降级<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td></tr><tr><td>2023/08/10</td><td><a href="https://openjdk.org/jeps/3#rc" target="_blank" rel="noopener noreferrer">初始候选发行版<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td></tr><tr><td>2023/08/24</td><td><a href="https://openjdk.org/jeps/3#rc" target="_blank" rel="noopener noreferrer">最终候选发行版<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></td></tr><tr><td>2023/09/19</td><td>正式发布</td></tr></tbody></table></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/wangfeng1996/LearnData/edit/main/docs/java/new-features/java21.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><!----></div></footer><nav class="vp-page-nav"><a class="vp-link nav-link prev" href="/java/new-features/java20.html"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->Java 20 新特性概览</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2025 有梦想的鱼🐟</div></footer></div><!--]--><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-37a49dbd.js" defer></script>
    <!-- 看板娘区块 -->
    <script src="/LearnData/live2d-widget/autoload.js"></script>
    <!-- End 看板娘区块 -->
    <script src="https://oss.newzone.top/instantpage.min.js" type="module"></script>
  </body>
</html>
