<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml" rel="self" type="application/rss+xml"/>
    <title>有梦想的鱼-开源博客</title>
    <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/</link>
    <description>业精于勤荒于嬉，行成于思毁于随</description>
    <language>zh-CN</language>
    <pubDate>Tue, 05 Mar 2024 08:35:26 GMT</pubDate>
    <lastBuildDate>Tue, 05 Mar 2024 08:35:26 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>mybatis</category>
    <category>mysql</category>
    <category>Java</category>
    <category>内网穿透</category>
    <category>Linux</category>
    <category>macOS</category>
    <category>算法</category>
    <category>shell</category>
    <category>homebrew</category>
    <item>
      <title>mybatis</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/java/mybatis/mybatis.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/java/mybatis/mybatis.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">mybatis</source>
      <category>mybatis</category>
      <pubDate>Tue, 05 Mar 2024 08:04:39 GMT</pubDate>
    </item>
    <item>
      <title>mysql</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/java/mysql/mysql.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/java/mysql/mysql.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">mysql</source>
      <description>mysql mysql全文索引分词器 https://blog.csdn.net/qq_29864051/article/details/125987138 https://www.alibabacloud.com/help/zh/analyticdb-for-mysql/developer-reference/analyzers-for-full-text-indexes mysql 多主键查询的实现 https://blog.51cto.com/u_16213391/7273288 mysql 自定义排序 FIELD mybatis的 string类型的和int 类型的判断 SpringBoot缓存中@CacheEvict注解删除缓存详解（@cache XXXX）</description>
      <category>mysql</category>
      <pubDate>Fri, 23 Feb 2024 01:47:41 GMT</pubDate>
      <content:encoded><![CDATA[<h1> mysql</h1>
<ul>
<li>mysql全文索引分词器
<ul>
<li><a href="https://blog.csdn.net/qq_29864051/article/details/125987138" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_29864051/article/details/125987138</a></li>
<li><a href="https://www.alibabacloud.com/help/zh/analyticdb-for-mysql/developer-reference/analyzers-for-full-text-indexes" target="_blank" rel="noopener noreferrer">https://www.alibabacloud.com/help/zh/analyticdb-for-mysql/developer-reference/analyzers-for-full-text-indexes</a></li>
</ul>
</li>
<li>mysql 多主键查询的实现
<ul>
<li><a href="https://blog.51cto.com/u_16213391/7273288" target="_blank" rel="noopener noreferrer">https://blog.51cto.com/u_16213391/7273288</a></li>
</ul>
</li>
<li>mysql 自定义排序 FIELD</li>
<li>mybatis的 string类型的和int 类型的判断</li>
<li>SpringBoot缓存中@CacheEvict注解删除缓存详解（@cache XXXX）</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 21 新特性概览</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/java/new-features/java21.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/java/new-features/java21.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">Java 21 新特性概览</source>
      <description>| 430: | String Templates (Preview)| 什么是 String Templates? String Templates 是 Java 15 中引入的一个新特性，它允许我们在字符串中使用占位符来动态替换变量的值。它提供了一种更简洁、更直观的方式来构建字符串，而不需要使用传统的字符串拼接或格式化方法。 为什么需要 String Templates? 在传统的 Java 中，我们通常使用字符串拼接或格式化方法来构建动态字符串。这种方式需要手动处理变量的值，并且容易出错。而且，当字符串中包含大量变量时，代码会变得冗长且难以维护。 String Templates 的引入解决了这个问题，它提供了一种更简洁、更易读的方式来构建动态字符串。通过使用占位符，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。 String Templates 的实现原理? String Templates 的实现原理是通过在字符串中使用占位符{} 解析为一个特殊的表达式，并将其转换为对应的变量值。这个过程是在编译时完成的，所以在运行时不会有额外的性能开销。 String Templates 的优点</description>
      <category>Java</category>
      <pubDate>Thu, 28 Sep 2023 09:16:36 GMT</pubDate>
      <content:encoded><![CDATA[<p>| 430: | String Templates (<a href="https://openjdk.org/jeps/430" target="_blank" rel="noopener noreferrer">Preview</a>)|</p>
<ol>
<li>什么是 String Templates?<br>
String Templates 是 Java 15 中引入的一个新特性，它允许我们在字符串中使用占位符来动态替换变量的值。它提供了一种更简洁、更直观的方式来构建字符串，而不需要使用传统的字符串拼接或格式化方法。</li>
<li>为什么需要 String Templates?<br>
在传统的 Java 中，我们通常使用字符串拼接或格式化方法来构建动态字符串。这种方式需要手动处理变量的值，并且容易出错。而且，当字符串中包含大量变量时，代码会变得冗长且难以维护。<br>
String Templates 的引入解决了这个问题，它提供了一种更简洁、更易读的方式来构建动态字符串。通过使用占位符，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。</li>
<li>String Templates 的实现原理?<br>
String Templates 的实现原理是通过在字符串中使用占位符{}<br>
解析为一个特殊的表达式，并将其转换为对应的变量值。这个过程是在编译时完成的，所以在运行时不会有额外的性能开销。</li>
<li>String Templates 的优点</li>
</ol>
<p>简洁易读：使用占位符${}来表示变量，使得代码更加简洁、易读。<br>
类型安全：String Templates 在编译时会进行类型检查，确保变量的类型与占位符的类型匹配，避免了运行时的类型错误。<br>
性能优化：String Templates 的解析过程是在编译时完成的，所以在运行时不会有额外的性能开销。<br>
可扩展性：String Templates 支持自定义的格式化函数，可以根据需求进行扩展。</p>
<ol start="5">
<li>String Templates 的缺点</li>
</ol>
<p>兼容性：String Templates 是 Java 15 中引入的新特性，需要使用 Java 15 或更高版本的 JDK 才能使用。<br>
语法限制：String Templates 的占位符${}只能用于表示变量，不能用于执行任意的表达式。<br>
可读性：当字符串中包含大量的占位符时，可能会降低代码的可读性。</p>
<ol start="6">
<li>String Templates 的使用示例<br>
下面是一个使用 String Templates 的简单示例：</li>
</ol>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果为：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="7">
<li>String Templates 的使用注意事项</li>
</ol>
<p>占位符{}中的变量值可以是任意类型，编译器会自动进行类型转换。<br>
如果变量值为 null，占位符{}中使用其他占位符。</p>
<ol start="8">
<li>总结<br>
String Templates 是 Java 15 中引入的一个新特性，它提供了一种更简洁、更直观的方式来构建动态字符串。通过使用占位符${}<br>
，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。String<br>
Templates 具有简洁易读、类型安全、性能优化和可扩展性等优点，但也存在兼容性、语法限制和可读性等缺点。在使用 String<br>
Templates 时，需要注意占位符的命名规则和变量值的类型。<br>
| 431: | <a href="https://openjdk.org/jeps/431" target="_blank" rel="noopener noreferrer">Sequenced Collections</a> |<br>
Sequenced Collections</li>
<li>什么是 Sequenced Collections？<br>
Sequenced Collections 是 Java 中的一个新特性，它是通过 JEP 431 引入的。Sequenced<br>
Collections 是一种新的集合类型，它提供了一种有序的、线程安全的集合实现。它的目标是提供一种高效的、可扩展的有序集合，以满足在多线程环境下处理大量数据的需求。</li>
<li>为什么需要 Sequenced Collections？<br>
在并发编程中，处理大量数据时，有序集合是非常常见的需求。然而，Java 标准库中的集合类（如 ArrayList、LinkedList<br>
等）并不是线程安全的，因此在多线程环境下使用它们可能会导致数据不一致的问题。为了解决这个问题，开发人员通常需要使用同步机制（如<br>
synchronized 关键字或 Lock 对象）来保证集合的线程安全性，但这会带来额外的开销和复杂性。<br>
Sequenced Collections 的目标就是提供一种高效的、可扩展的有序集合，以解决在多线程环境下处理大量数据时的线程安全问题。</li>
<li>Sequenced Collections 的实现原理<br>
Sequenced Collections 的实现基于一种称为"Sequenced Locks"的机制。Sequenced<br>
Locks 是一种特殊的锁机制，它允许多个线程同时读取集合中的数据，但只允许一个线程进行写操作。这种机制可以提高并发性能，同时保证数据的一致性。<br>
在 Sequenced<br>
Collections 中，每个元素都有一个唯一的序列号，用于标识元素的顺序。读操作可以并发进行，而写操作则需要获取锁来保证原子性。当一个线程进行写操作时，其他线程可以继续读取集合中的数据，但不能进行写操作，直到写操作完成。</li>
<li>Sequenced Collections 的优点</li>
</ol>
<p>线程安全：Sequenced Collections 提供了线程安全的集合实现，可以在多线程环境下安全地访问和修改集合中的数据。<br>
高效性能：Sequenced Collections 使用了 Sequenced Locks 机制，可以提高并发性能，同时保证数据的一致性。<br>
可扩展性：Sequenced Collections 的设计考虑了可扩展性，可以处理大量数据的并发访问。</p>
<ol start="5">
<li>Sequenced Collections 的缺点</li>
</ol>
<p>额外开销：Sequenced Collections 的实现需要维护元素的序列号和锁机制，这会带来一定的额外开销。<br>
写操作的延迟：由于写操作需要获取锁来保证原子性，可能会导致其他线程在写操作完成之前无法进行写操作。</p>
<ol start="6">
<li>Sequenced Collections 的使用示例<br>
下面是一个使用 Sequenced Collections 的简单示例：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们使用了 SequencedHashMap 来创建一个有序的、线程安全的集合。我们可以使用 put 方法添加元素，使用 get<br>
方法获取元素，使用 forEach 方法遍历元素。</p>
<ol start="7">
<li>Sequenced Collections 的其他注意事项</li>
</ol>
<p>Sequenced Collections 是 Java 标准库的一部分，从 Java 17 开始引入。<br>
Sequenced Collections 提供了多种集合类型，如 SequencedHashMap、SequencedArrayList 等。<br>
Sequenced Collections 可以与其他 Java 集合类（如 ArrayList、LinkedList 等）一起使用，以满足不同的需求。</p>
<ol start="8">
<li>总结<br>
Sequenced Collections 是 Java 中的一个新特性，它提供了一种有序的、线程安全的集合实现。它通过使用 Sequenced<br>
Locks 机制来保证线程安全性和并发性能。Sequenced Collections 具有高效性能、可扩展性等优点，但也存在额外开销和写操作延迟的缺点。在使用<br>
Sequenced<br>
Collections 时，我们可以创建 SequencedHashMap、SequencedArrayList 等集合类型，并使用 put、get、forEach 等方法来操作集合中的数据。</li>
</ol>
<p>| 439: | <a href="https://openjdk.org/jeps/439" target="_blank" rel="noopener noreferrer">Generational ZGC</a> |</p>
<ol>
<li>什么是 Generational ZGC?<br>
Generational ZGC（Z Garbage Collector）是一种用于 Java 虚拟机（JVM）的垃圾回收器。它是 OpenJDK<br>
项目中的一个特性，旨在提供低延迟和高吞吐量的垃圾回收解决方案。</li>
<li>为什么需要 Generational ZGC?<br>
传统的垃圾回收器在处理大型堆内存时可能会导致长时间的停顿，这对于需要快速响应和低延迟的应用程序来说是不可接受的。Generational<br>
ZGC 的目标是减少这些停顿时间，并且能够处理非常大的堆内存。</li>
<li>Generational ZGC 的实现原理<br>
Generational ZGC 基于分代垃圾回收的概念，将堆内存划分为多个代。其中包括 Young Generation（年轻代）和 Old<br>
Generation（老年代）。具体的实现原理如下：<br>
年轻代（Young Generation）</li>
</ol>
<p>年轻代使用了 Region 的概念，将整个年轻代划分为多个大小相等的区域。<br>
每个区域都有一个指针指向下一个可用的区域，形成一个链表结构。<br>
当对象被创建时，它们首先被分配到年轻代的某个区域中。<br>
当一个区域被填满时，会触发一次年轻代垃圾回收（Minor GC）。<br>
Minor GC 使用了并行和压缩算法来回收不再使用的对象。</p>
<p>老年代（Old Generation）</p>
<p>老年代是存放生命周期较长的对象的区域。<br>
当一个对象在年轻代经历了多次垃圾回收后仍然存活，它将被晋升到老年代。<br>
当老年代空间不足时，会触发一次老年代垃圾回收（Major GC）。<br>
Major GC 使用了并发标记和并行清理算法来回收不再使用的对象。</p>
<p>并发处理<br>
Generational ZGC 采用了并发处理的方式来减少停顿时间。具体包括：</p>
<p>年轻代垃圾回收过程中，应用程序可以继续执行。<br>
在老年代垃圾回收过程中，应用程序也可以继续执行，只有在最后的清理阶段才会产生短暂的停顿。</p>
<ol start="4">
<li>Generational ZGC 的优点</li>
</ol>
<p>低延迟：Generational ZGC 通过并发处理和分代回收的策略，实现了非常低的停顿时间，适合对响应时间要求高的应用场景。<br>
高吞吐量：Generational ZGC 在尽可能减少停顿时间的同时，也能保持较高的垃圾回收吞吐量。<br>
大堆支持：Generational ZGC 可以处理非常大的堆内存，适用于需要大内存容量的应用程序。</p>
<ol start="5">
<li>Generational ZGC 的缺点</li>
</ol>
<p>性能开销：由于并发处理和分代回收的策略，Generational ZGC 会带来一定的性能开销。这主要体现在 CPU 和内存的使用上。<br>
配置复杂：Generational ZGC 有一些与性能相关的配置参数，需要根据具体场景进行调整，对于不熟悉的用户来说可能比较复杂。</p>
<ol start="6">
<li>
<p>Generational ZGC 的使用示例<br>
以下是一个简单的 Java 代码示例，展示了如何启用 Generational ZGC：<br>
java复制代码java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC YourApplication</p>
</li>
<li>
<p>Generational ZGC 的使用注意事项</p>
</li>
</ol>
<p>Generational ZGC 是 OpenJDK 项目中的新特性，虽然已经相当稳定，但仍然建议在生产环境中进行充分测试。<br>
在使用 Generational ZGC 时，建议监控系统资源使用情况，以便及时调整配置参数或采取其他措施来优化性能。</p>
<ol start="8">
<li>总结<br>
Generational ZGC 是一种用于 Java 虚拟机的垃圾回收器，旨在提供低延迟和高吞吐量的垃圾回收解决方案。它通过并发处理和分代回收的策略，实现了非常低的停顿时间，并且能够处理非常大的堆内存。然而，使用<br>
Generational<br>
ZGC 需要注意性能开销和配置复杂性。<br>
| 440: | <a href="https://openjdk.org/jeps/440" target="_blank" rel="noopener noreferrer">Record Patterns</a> |</li>
<li>什么是 Record Patterns?<br>
Record Patterns 是 Java 16 中引入的一个新特性，它允许我们在模式匹配中使用记录类型（record<br>
types）。记录类型是一种新的类声明形式，用于定义不可变的数据对象。而 Record Patterns<br>
则提供了一种简洁的方式来进行模式匹配，并且可以方便地从记录类型中提取字段值。</li>
<li>为什么需要 Record Patterns?<br>
在传统的 Java 编程中，当我们需要对某个对象的属性进行判断和提取时，通常需要手动编写大量的代码来完成这些操作。而引入<br>
Record<br>
Patterns 可以极大地简化这个过程，使得代码更加清晰、简洁，并且减少了出错的可能性。</li>
<li>Record Patterns 的实现原理<br>
Record Patterns 的实现原理主要涉及两个方面：记录类型和模式匹配。<br>
记录类型<br>
记录类型是一种新的类声明形式，通过 record 关键字来定义。它自动提供了以下功能：</li>
</ol>
<p>自动生成私有 final 字段，并根据构造函数参数初始化这些字段。<br>
自动生成 equals()、hashCode() 和 toString() 方法。<br>
提供了一种紧凑的语法来定义字段和构造函数。</p>
<p>模式匹配<br>
模式匹配是指根据给定的模式来匹配某个对象，并执行相应的操作。在 Record Patterns 中，我们可以使用 instanceof<br>
关键字和模式变量来进行模式匹配。<br>
具体地说，当我们使用 Record Patterns<br>
进行模式匹配时，编译器会自动为记录类型生成一个模式匹配方法。这个方法接受一个对象作为参数，并根据给定的模式进行匹配。如果匹配成功，则将字段值绑定到相应的模式变量中，从而可以在后续代码中使用。</p>
<ol start="4">
<li>Record Patterns 的优点<br>
Record Patterns 带来了以下几个优点：</li>
</ol>
<p>简洁性：使用 Record Patterns 可以大大简化对记录类型的模式匹配操作，减少冗余代码。<br>
可读性：Record Patterns 提供了一种直观、清晰的语法，使得代码更易于理解和维护。<br>
安全性：由于 Record Patterns 自动生成了 equals() 和 hashCode() 方法，可以避免手动实现这些方法时可能出现的错误。<br>
提高开发效率：Record Patterns 可以减少重复劳动，提高开发效率。</p>
<ol start="5">
<li>Record Patterns 的缺点<br>
尽管 Record Patterns 带来了很多好处，但也存在一些限制和缺点：</li>
</ol>
<p>不可变性：记录类型是不可变的，即字段值不能被修改。这意味着如果需要修改某个字段的值，就必须创建一个新的记录对象。<br>
局限性：Record Patterns 目前只能用于记录类型，不能用于其他类。<br>
兼容性：由于 Record Patterns 是在 Java 16 中引入的新特性，因此需要使用 Java 16 或更高版本才能使用。</p>
<ol start="6">
<li>Record Patterns 的使用示例<br>
下面是一个简单的示例，展示了如何使用 Record Patterns 进行模式匹配：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们定义了一个名为 Person 的记录类型，并创建了一个 Person 对象。然后，我们使用 Record Patterns<br>
进行模式匹配，将字段值绑定到模式变量 p 中，并输出字段值。</p>
<ol start="7">
<li>Record Patterns 的使用注意事项<br>
在使用 Record Patterns 时，需要注意以下几点：</li>
</ol>
<p>记录类型的字段默认是 final 的，即不能被修改。如果需要修改某个字段的值，就必须创建一个新的记录对象。<br>
记录类型的构造函数参数和字段名称要一致，否则会导致编译错误。<br>
模式匹配方法的命名规则是 <code>match&lt;RecordTypeName&gt;</code>，例如 matchPerson()。</p>
<ol start="8">
<li>总结<br>
Record Patterns 是 Java 16 引入的一个新特性，它提供了一种简洁、清晰的方式来进行模式匹配，并且可以方便地从记录类型中提取字段值。使用<br>
Record Patterns 可以使代码更加简洁、可读，并提高开发效率。然而，由于记录类型是不可变的，因此在修改字段值时需要创建新的对象。同时，Record<br>
Patterns 目前只能用于记录类型，不能用于其他类。</li>
</ol>
<p>| 441: | <a href="https://openjdk.org/jeps/441" target="_blank" rel="noopener noreferrer">Pattern Matching for switch</a> |</p>
<ol>
<li>什么是 Pattern Matching for switch?<br>
Pattern Matching for switch 是 Java 14 中引入的一个新特性，它允许在 switch 语句中使用模式匹配。通过这个特性，我们可以更方便地对变量进行类型判断和提取。</li>
<li>为什么需要 Pattern Matching for switch?<br>
在之前的 Java 版本中，如果我们想要根据不同的类型执行不同的逻辑，通常需要使用多个 if-else 或者 switch-case<br>
来进行判断。这样的代码结构比较冗长，并且容易出错。而 Pattern Matching for switch 的引入，使得我们能够更简洁、清晰地处理这种情况。</li>
<li>Pattern Matching for switch 的实现原理<br>
Pattern Matching for switch 的实现原理主要涉及两个方面：模式匹配和类型推断。<br>
模式匹配<br>
模式匹配是指将某个值与一系列模式进行比较，以确定是否匹配。在 Pattern Matching for switch 中，我们可以使用关键字 case<br>
后跟上模式来进行匹配。例如：</li>
</ol>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，case String s 和 case Integer i 就是模式，它们分别用于匹配字符串和整数类型的对象。<br>
类型推断<br>
类型推断是指根据上下文信息，自动推断出某个表达式的类型。在 Pattern Matching for switch 中，我们可以使用 var<br>
关键字来进行类型推断。例如：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，var 关键字用于推断 result 的类型为 int。</p>
<ol start="4">
<li>Pattern Matching for switch 的优点</li>
</ol>
<p>简化了对变量类型的判断和提取逻辑，使代码更加简洁、清晰。<br>
减少了重复的代码，提高了开发效率。<br>
增强了代码的可读性和可维护性。</p>
<ol start="5">
<li>Pattern Matching for switch 的缺点</li>
</ol>
<p>只能用于 switch 语句中，不能直接用于 if-else 结构。<br>
目前只支持基本数据类型和引用类型的模式匹配，不支持其他特殊类型（如枚举、数组等）的模式匹配。</p>
<ol start="6">
<li>Pattern Matching for switch 的使用示例<br>
下面是一个使用 Pattern Matching for switch 的示例代码：</li>
</ol>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述代码中，根据传入的对象类型不同，会执行相应的逻辑。</p>
<ol start="7">
<li>Pattern Matching for switch 的使用注意事项</li>
</ol>
<p>模式匹配是按照 case 的顺序进行匹配的，因此需要将更具体的模式放在前面。<br>
如果没有匹配到任何模式，则会执行 default 分支的逻辑。<br>
在一个 switch 块内部，每个模式只能出现一次，否则会编译报错。</p>
<ol start="8">
<li>总结<br>
Pattern Matching for switch 是 Java 14 中引入的一个新特性，它允许在 switch<br>
语句中使用模式匹配。通过这个特性，我们可以更方便地对变量进行类型判断和提取。它简化了对变量类型的判断和提取逻辑，使代码更加简洁、清晰，并且增强了代码的可读性和可维护性。但需要注意的是，目前只支持基本数据类型和引用类型的模式匹配，不支持其他特殊类型的模式匹配。</li>
</ol>
<p>| 442: | <a href="https://openjdk.org/jeps/442" target="_blank" rel="noopener noreferrer">Foreign Function &amp; Memory API (Third Preview)</a> |</p>
<ol>
<li>什么是 Foreign Function &amp; Memory API (Third Preview)?<br>
Foreign Function &amp; Memory API 是 Java 平台的一个功能，它允许开发者直接与本地代码进行交互，并且可以在 Java<br>
中操作本地内存。这个功能最初在<br>
JDK 14 的时候以 JEP 383 的形式引入了第一次预览版，然后在 JDK 15 中进一步改进并发布了第二次预览版（JEP 393），现在在 JDK<br>
21<br>
中发布了第三次预览版（JEP 442）。</li>
<li>为什么需要 Foreign Function &amp; Memory API?<br>
Foreign Function &amp; Memory API 的出现主要是为了解决以下几个问题：</li>
</ol>
<p>与本地代码的无缝集成：有些场景下，我们可能需要调用本地库或者系统级别的函数，例如使用硬件加速、调用底层操作系统的特定功能等。而<br>
Foreign Function &amp; Memory API 可以使得 Java 程序能够直接调用本地函数，从而实现与本地代码的无缝集成。<br>
提高性能：通过直接操作本地内存，可以避免数据拷贝和类型转换带来的性能损耗，从而提高程序的执行效率。<br>
扩展现有 Java 库的功能：Foreign Function &amp; Memory API 提供了一种机制，可以将本地库中的函数包装成 Java 接口，从而方便地扩展现有的<br>
Java 库的功能。</p>
<ol start="3">
<li>Foreign Function &amp; Memory API 的实现原理<br>
Foreign Function &amp; Memory API 的实现主要依赖于以下几个关键技术：</li>
</ol>
<p>JNI（Java Native Interface）：JNI 是 Java 平台提供的一种机制，用于在 Java 程序中调用本地代码。Foreign Function &amp; Memory<br>
API 利用 JNI 提供的能力，使得 Java 程序可以直接调用本地函数。<br>
内存管理：Foreign Function &amp; Memory API 允许开发者直接操作本地内存，包括分配、释放和读写等操作。这需要对内存进行有效的管理，以确保安全性和可靠性。<br>
类型映射：由于 Java 和本地代码使用不同的数据类型表示数据，因此需要进行类型映射。Foreign Function &amp; Memory API<br>
提供了一套规则和工具，用于将 Java 类型与本地类型进行转换。</p>
<ol start="4">
<li>Foreign Function &amp; Memory API 的优点</li>
</ol>
<p>无缝集成：Foreign Function &amp; Memory API 可以使得 Java 程序能够直接调用本地函数，从而实现与本地代码的无缝集成。<br>
高性能：通过直接操作本地内存，避免了数据拷贝和类型转换带来的性能损耗，从而提高程序的执行效率。<br>
灵活性：Foreign Function &amp; Memory API 提供了丰富的功能和灵活的接口，可以满足不同场景下的需求。</p>
<ol start="5">
<li>Foreign Function &amp; Memory API 的缺点</li>
</ol>
<p>安全性风险：直接操作本地内存可能会带来一些安全风险，例如内存泄漏、访问非法内存等。因此，在使用 Foreign Function &amp;<br>
Memory API 时需要谨慎处理，并遵循相关的安全规范。<br>
复杂性：Foreign Function &amp; Memory API 涉及到与本地代码的交互和内存管理等复杂的问题，对开发者的要求较高，需要具备一定的底层编程知识和经验。</p>
<ol start="6">
<li>Foreign Function &amp; Memory API 的使用示例<br>
以下是一个简单的示例，展示了如何使用 Foreign Function &amp; Memory API 调用本地函数：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述示例中，我们使用 Foreign Function &amp; Memory API 调用了本地的 printf 函数，并将结果打印出来。</p>
<ol start="7">
<li>Foreign Function &amp; Memory API 的使用注意事项</li>
</ol>
<p>在使用 Foreign Function &amp; Memory API 时，需要确保本地函数和库已经正确安装并可用。<br>
对于直接操作本地内存的情况，需要特别注意内存管理和安全性问题，避免出现内存泄漏、访问非法内存等问题。<br>
使用 Foreign Function &amp; Memory API 需要谨慎处理异常，以确保程序的稳定性和可靠性。</p>
<ol start="8">
<li>总结<br>
Foreign Function &amp; Memory API 是 Java 平台提供的一种机制，可以使得 Java 程序能够直接调用本地函数，并且可以在 Java<br>
中操作本地内存。它通过 JNI 技术实现与本地代码的无缝集成，并提供了高性能和灵活性。然而，在使用 Foreign Function &amp; Memory<br>
API<br>
时需要注意安全性和复杂性等问题，以确保程序的稳定性和可靠性。</li>
</ol>
<p>| 443: | <a href="https://openjdk.org/jeps/443" target="_blank" rel="noopener noreferrer">Unnamed Patterns and Variables (Preview)</a> |</p>
<ol>
<li>什么是 Unnamed Patterns and Variables (Preview)?<br>
Unnamed Patterns and Variables 是 Java 编程语言的一个新特性，它在 JDK 14 中引入，并在 JDK 15<br>
中作为预览功能继续存在。该特性允许我们使用匿名模式和变量来简化代码并提高可读性。</li>
<li>为什么需要 Unnamed Patterns and Variables?<br>
在传统的 Java 代码中，当我们需要对某个对象进行模式匹配时，通常需要创建一个临时变量来存储匹配结果。这样会导致代码冗长、可读性差，并且增加了不必要的命名负担。<br>
而 Unnamed Patterns and Variables 的出现正是为了解决这个问题。通过使用匿名模式和变量，我们可以直接在模式匹配表达式中使用，避免了创建临时变量的麻烦，使得代码更加简洁和易于理解。</li>
<li>Unnamed Patterns and Variables 的实现原理<br>
Unnamed Patterns and Variables 的实现原理主要涉及两个方面：匿名模式和匿名变量。<br>
匿名模式<br>
匿名模式是一种特殊的模式，用于表示我们只关心某个值是否满足某个条件，而不关心具体的值是什么。在匿名模式中，我们使用下划线 _<br>
来代替具体的变量名。<br>
例如，我们可以使用匿名模式来判断一个对象是否为 null：<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p>匿名变量<br>
匿名变量是一种特殊的变量，用于表示我们不需要使用该变量的值。在匿名变量中，我们同样使用下划线 _ 来代替具体的变量名。<br>
例如，在 switch 语句中，我们可以使用匿名变量来忽略某些分支的返回值：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>Unnamed Patterns and Variables 的优点</li>
</ol>
<p>简化代码：通过使用匿名模式和变量，可以减少临时变量的创建，使得代码更加简洁。<br>
提高可读性：匿名模式和变量能够直接表达我们关心的条件，避免了命名的繁琐，使得代码更易于理解。</p>
<ol start="5">
<li>Unnamed Patterns and Variables 的缺点<br>
由于 Unnamed Patterns and Variables 目前仍处于预览阶段，因此存在以下一些限制和潜在问题：</li>
</ol>
<p>兼容性问题：由于该特性是在 JDK 14 中引入的，并且仍处于预览阶段，因此可能存在与旧版本 Java 不兼容的问题。<br>
语法限制：匿名模式和变量只能用于某些特定的上下文中，不能在所有地方使用。例如，在 lambda 表达式、方法引用等场景中暂时还无法使用。</p>
<ol start="6">
<li>Unnamed Patterns and Variables 的使用示例<br>
以下是一个使用匿名模式和变量的示例代码，用于判断一个对象是否为非空字符串：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>Unnamed Patterns and Variables 的使用注意事项<br>
在使用 Unnamed Patterns and Variables 时，需要注意以下几点：</li>
</ol>
<p>匿名模式和变量只能用于表示我们不关心具体值的情况，如果需要获取具体的值，则应该使用普通的命名模式和变量。<br>
在一些特殊的上下文中，如 lambda 表达式、方法引用等，目前还无法使用匿名模式和变量。</p>
<ol start="8">
<li>总结<br>
Unnamed Patterns and Variables 是 Java<br>
编程语言的一个新特性，它通过引入匿名模式和变量来简化代码并提高可读性。虽然该特性目前仍处于预览阶段，并存在一些限制和潜在问题，但它为我们编写更简洁、易读的代码提供了一种新的方式。</li>
</ol>
<p>| 444: | <a href="https://openjdk.org/jeps/444" target="_blank" rel="noopener noreferrer">Virtual Threads</a> |</p>
<ol>
<li>什么是 Virtual Threads?<br>
Virtual Threads（虚拟线程）是 Java 平台的一项新功能，它旨在改进 Java 中的并发编程模型。传统上，Java<br>
使用基于操作系统线程的并发模型，每个线程都需要分配一个操作系统线程来执行。而 Virtual<br>
Threads 则提供了一种更高效、更轻量级的线程模型。</li>
<li>为什么需要 Virtual Threads?<br>
在传统的基于操作系统线程的并发模型中，创建和销毁线程以及在线程之间切换的开销很大。这限制了 Java<br>
应用程序在处理大规模并发时的性能和扩展性。此外，由于操作系统线程的数量有限，当应用程序需要创建大量线程时，可能会导致资源耗尽或者性能下降。<br>
Virtual<br>
Threads 的出现解决了这些问题。它通过引入一种轻量级的线程模型，可以在 Java 应用程序中创建数百万甚至数十亿个线程，而不会受到操作系统线程数量的限制。这使得<br>
Java 应用程序能够更好地适应大规模并发场景，并提供更高的性能和可伸缩性。</li>
<li>Virtual Threads 的实现原理<br>
Virtual Threads 的实现依赖于 Java 虚拟机（JVM）的协作调度器和 Fork/Join 框架。它通过将多个 Virtual<br>
Threads 映射到少量的操作系统线程上来实现高效的并发执行。<br>
具体而言，当一个 Java 应用程序创建一个 Virtual<br>
Thread 时，JVM 会为其分配一个虚拟线程（也称为轻量级线程）。这些虚拟线程由协作调度器管理，并在需要时与操作系统线程进行绑定。协作调度器负责决定哪个虚拟线程可以运行以及何时切换虚拟线程。<br>
Fork/Join 框架是 Virtual Threads 的另一个关键组件。它提供了一种任务并行编程模型，允许开发人员将任务分解成更小的子任务，并使用工作窃取算法来实现负载均衡。Virtual<br>
Threads 利用 Fork/Join 框架的能力，在不同的虚拟线程之间自动地、透明地进行任务划分和调度。</li>
<li>Virtual Threads 的优点</li>
</ol>
<p>更高的性能：Virtual Threads 减少了线程创建和销毁的开销，同时避免了操作系统线程数量的限制，从而提供更高的性能。<br>
更好的可伸缩性：由于 Virtual Threads 可以创建数百万甚至数十亿个线程，因此 Java 应用程序可以更好地适应大规模并发场景，并具有更好的可伸缩性。<br>
更低的资源消耗：相比于操作系统线程，Virtual Threads 是轻量级的，占用更少的内存和 CPU 资源。</p>
<ol start="5">
<li>Virtual Threads 的缺点<br>
虽然 Virtual Threads 带来了许多优势，但也存在一些潜在的缺点：</li>
</ol>
<p>学习成本较高：使用 Virtual Threads 需要对并发编程模型有一定的理解，并且需要适应新的 API 和开发范式。<br>
可能引入新的问题：由于 Virtual Threads 是一个相对较新的功能，可能会存在一些未知的问题或者不稳定性。</p>
<ol start="6">
<li>Virtual Threads 的使用示例<br>
下面是一个简单的使用 Virtual Threads 的示例代码：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述示例中，我们使用Executors.newVirtualThreadExecutor()方法创建了一个ThreadPoolExecutor实例，该实例可以执行 Virtual<br>
Threads。然后，我们通过调用execute()方法提交了一系列任务，每个任务都会打印当前运行的虚拟线程的名称。</p>
<ol start="7">
<li>Virtual Threads 的使用注意事项<br>
在使用 Virtual Threads 时，需要注意以下几点：</li>
</ol>
<p>虽然 Virtual Threads 可以创建大量线程，但过多的线程仍可能导致性能下降或资源耗尽。因此，在设计应用程序时，仍需合理控制并发度。<br>
使用 Virtual Threads 时，需要遵循良好的并发编程实践，如避免共享可变状态、使用适当的同步机制等，以确保线程安全性和正确性。<br>
在迁移现有代码到使用 Virtual Threads 时，需要进行一定的重构和调整，以适应新的 API 和开发范式。</p>
<ol start="8">
<li>总结<br>
Virtual Threads 是 Java 平台的一项新功能，旨在改进 Java 中的并发编程模型。它通过引入轻量级的虚拟线程，并利用协作调度器和<br>
Fork/Join 框架来提供高效的并发执行。Virtual<br>
Threads 具有更高的性能、更好的可伸缩性和较低的资源消耗，但也需要学习成本较高，并且可能存在一些潜在的问题。在使用 Virtual<br>
Threads 时，需要注意合理控制并发度、遵循并发编程实践，并进行必要的重构和调整。</li>
</ol>
<p>| 445: | <a href="https://openjdk.org/jeps/445" target="_blank" rel="noopener noreferrer">Unnamed Classes and Instance Main Methods (Preview)</a>|</p>
<ol>
<li>什么是 Unnamed Classes and Instance Main Methods (Preview)?<br>
"Unnamed Classes and Instance Main Methods" 是一个 Java 编程语言的新特性，它在 JDK 14 中引入，并在 JDK 15<br>
中成为预览功能。该特性允许我们在类中定义匿名类和实例主方法。<br>
在传统的 Java 编程中，我们只能在顶级类或静态内部类中定义 main 方法作为程序的入口点。而使用 "Unnamed Classes and<br>
Instance<br>
Main Methods" 特性后，我们可以在任何类的实例中定义 main 方法，从而使得程序的入口点更加灵活。</li>
<li>为什么需要 Unnamed Classes and Instance Main Methods?<br>
传统的 Java 程序必须将 main<br>
方法定义在顶级类或静态内部类中，这限制了程序的结构和组织方式。有时候，我们可能希望将多个相关的逻辑封装在同一个类的实例中，以提高代码的可读性和可维护性。而 "<br>
Unnamed Classes and Instance Main Methods" 特性正是为了满足这种需求而引入的。<br>
通过在类的实例中定义 main 方法，我们可以更好地组织和管理程序的逻辑，减少顶级类和静态内部类的数量，使代码更加清晰和易于理解。</li>
<li>Unnamed Classes and Instance Main Methods 的实现原理<br>
"Unnamed Classes and Instance Main Methods" 特性的实现原理涉及到两个方面：匿名类和实例主方法。<br>
3.1 匿名类<br>
在 Java 中，我们可以使用匿名类来创建一个没有显式名称的类。匿名类通常用于创建临时的、只需要一次使用的类对象。它们可以继承自某个类或实现某个接口，并重写其中的方法。<br>
匿名类的语法如下：<br>
java复制代码new 父类构造器(参数列表) {<br>
// 匿名类的成员变量和方法定义<br>
}</li>
</ol>
<p>3.2 实例主方法<br>
传统的 Java 程序入口点是通过静态 main 方法来定义的，而 "Unnamed Classes and Instance Main Methods" 特性允许我们在类的实例中定义<br>
main 方法。<br>
实例主方法的语法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4">
<li>Unnamed Classes and Instance Main Methods 的优点</li>
</ol>
<p>灵活性：通过在类的实例中定义 main 方法，程序的入口点更加灵活，可以根据需求将多个相关的逻辑封装在同一个类的实例中。<br>
可读性：将相关的逻辑组织在同一个类的实例中，使得代码更加清晰和易于理解。<br>
可维护性：减少顶级类和静态内部类的数量，简化代码结构，提高代码的可维护性。</p>
<ol start="5">
<li>Unnamed Classes and Instance Main Methods 的缺点</li>
</ol>
<p>语法复杂：匿名类和实例主方法的语法相对传统的 main 方法更加复杂，需要额外的学习成本。<br>
可读性降低：如果滥用该特性，将多个逻辑封装在同一个类的实例中可能会导致代码可读性下降。</p>
<ol start="6">
<li>Unnamed Classes and Instance Main Methods 的使用示例<br>
下面是一个使用 "Unnamed Classes and Instance Main Methods" 特性的示例：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p>在上述示例中，我们定义了一个名为 Example 的类，并在其中创建了一个实例。通过调用实例的 main<br>
方法，程序的入口点被指定为该实例的 main 方法。</p>
<ol start="7">
<li>Unnamed Classes and Instance Main Methods 的使用注意事项</li>
</ol>
<p>在使用 "Unnamed Classes and Instance Main Methods" 特性时，需要确保每个类的实例只有一个 main 方法，否则编译器将无法确定程序的入口点。<br>
匿名类和实例主方法的语法较为复杂，需要仔细理解并遵循正确的语法规则。<br>
虽然 "Unnamed Classes and Instance Main Methods" 特性在 JDK 15 中成为预览功能，但仍然存在一些潜在的问题和限制。在使用时需要注意这些问题，并及时反馈给开发团队。</p>
<ol start="8">
<li>总结<br>
"Unnamed Classes and Instance Main Methods" 是 Java<br>
编程语言的一个新特性，它允许我们在类的实例中定义匿名类和实例主方法。通过该特性，我们可以更灵活地组织程序的逻辑，提高代码的可读性和可维护性。然而，使用该特性需要注意语法复杂性和可读性降低的问题，并遵循正确的使用方式。</li>
</ol>
<p>| 446: | <a href="https://openjdk.org/jeps/446" target="_blank" rel="noopener noreferrer">Scoped Values (Preview)</a>|</p>
<ol>
<li>什么是 Scoped Values (Preview)?<br>
Scoped Values (Preview) 是 Java 平台的一个新特性，它在 JDK 17 中引入。该特性旨在提供一种机制，用于在代码块级别上设置和使用临时变量。</li>
<li>为什么需要 Scoped Values (Preview)?<br>
在传统的 Java 编程中，我们通常会将变量声明在方法或类的作用域内，并且这些变量的生命周期与其所在的作用域相同。然而，在某些情况下，我们可能希望在更小的范围内定义临时变量，以便更好地控制其可见性和生命周期。<br>
Scoped Values (Preview) 提供了一种简洁、安全的方式来定义和使用临时变量，使得代码更加清晰易读，并且可以减少不必要的命名冲突和资源泄漏问题。</li>
<li>Scoped Values (Preview) 的实现原理?<br>
Scoped Values (Preview) 的实现基于 Java 语言规范中的局部变量类型推断（Local Variable Type Inference）机制。通过使用 var<br>
关键字，我们可以在代码块内部声明临时变量，并根据初始化表达式的类型进行类型推断。<br>
例如，以下示例展示了如何使用 Scoped Values (Preview) 声明和使用临时变量：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p>在上述示例中，我们使用 Scoped Values (Preview) 声明了一个名为 message 的临时变量，并将其初始化为字符串 "Hello, World!"<br>
。然后，在 if 语句的代码块内部，我们可以直接使用该临时变量。</p>
<ol start="4">
<li>Scoped Values (Preview) 的优点</li>
</ol>
<p>简洁性：Scoped Values (Preview) 提供了一种更简洁的方式来声明和使用临时变量，减少了冗余的代码。<br>
可读性：通过在代码块级别上定义临时变量，使得代码更加清晰易读，提高了代码的可维护性。<br>
类型安全：Scoped Values (Preview) 基于 Java 语言规范中的局部变量类型推断机制，确保了变量的类型安全性。</p>
<ol start="5">
<li>Scoped Values (Preview) 的缺点<br>
尽管 Scoped Values (Preview) 提供了许多优点，但也存在一些潜在的缺点：</li>
</ol>
<p>兼容性问题：由于 Scoped Values (Preview) 是 JDK 17 中引入的新特性，因此在较旧版本的 Java 中无法使用。<br>
学习成本：对于不熟悉局部变量类型推断机制的开发人员来说，可能需要一些时间来适应 Scoped Values (Preview) 的使用方式。</p>
<ol start="6">
<li>Scoped Values (Preview) 的使用示例<br>
以下是一个使用 Scoped Values (Preview) 的简单示例：<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p>在上述示例中，我们使用 Scoped Values (Preview) 声明了一个名为 message 的临时变量，并将其初始化为字符串 "Hello, World!"<br>
。然后，我们通过调用 System.out.println 方法打印该临时变量的值。</p>
<ol start="7">
<li>Scoped Values (Preview) 的使用注意事项<br>
在使用 Scoped Values (Preview) 时，需要注意以下几点：</li>
</ol>
<p>作用域限制：Scoped Values (Preview) 声明的临时变量仅在当前代码块内部可见，超出该代码块范围后将无法访问。<br>
类型推断：由于 Scoped Values (Preview) 是基于局部变量类型推断机制实现的，因此必须确保初始化表达式具有明确的类型信息，以便进行正确的类型推断。<br>
命名冲突：当在同一代码块内使用多个 Scoped Values (Preview) 声明临时变量时，需要避免命名冲突，以免引起混淆和错误。</p>
<ol start="8">
<li>总结<br>
Scoped Values (Preview) 是 Java 平台的一个新特性，它提供了一种在代码块级别上设置和使用临时变量的机制。通过使用 var<br>
关键字，我们可以在代码块内部声明临时变量，并根据初始化表达式的类型进行类型推断。Scoped Values (Preview)<br>
的优点包括简洁性、可读性和类型安全性，但也存在兼容性问题和学习成本。在使用 Scoped Values (Preview)<br>
时，需要注意作用域限制、类型推断和命名冲突等注意事项。</li>
</ol>
<p>| 448: | <a href="https://openjdk.org/jeps/448" target="_blank" rel="noopener noreferrer">Vector API (Sixth Incubator)</a>|</p>
<ol>
<li>什么是 Vector API (Sixth Incubator)?<br>
Vector API (Sixth Incubator) 是 Java 平台的一个项目，旨在提供一种简单且高效的方式来执行向量化计算。它引入了新的类和接口，以支持使用<br>
SIMD（Single Instruction, Multiple Data）指令集进行并行计算。</li>
<li>为什么需要 Vector API (Sixth Incubator)?<br>
在许多应用程序中，存在大量的数据并行计算任务，例如图像处理、科学计算和机器学习等领域。传统的 Java<br>
编程模型无法充分利用现代硬件的并行计算能力，导致性能低下。而 Vector API (Sixth Incubator) 的目标就是通过向量化计算来提高这些应用程序的性能。</li>
<li>Vector API (Sixth Incubator) 的实现原理?<br>
Vector API (Sixth Incubator) 基于 SIMD 指令集，即单指令多数据流指令集。SIMD 指令集可以同时对多个数据元素执行相同的操作，从而实现并行计算。Vector<br>
API (Sixth Incubator) 提供了一组新的类和接口，使开发人员能够直接编写基于 SIMD 指令集的代码。<br>
具体来说，Vector API (Sixth Incubator) 引入了 java.util.vector 包，其中包含了一些新的类和接口，如 Vector、FloatVector<br>
和 IntVector 等。这些类提供了一组向量化操作方法，例如加法、减法、乘法等，以及对应的掩码操作。<br>
在底层实现上，Vector API (Sixth Incubator) 使用了特定硬件平台的 SIMD 指令集来执行向量化计算。具体实现细节会依赖于不同的硬件架构和操作系统。</li>
<li>Vector API (Sixth Incubator) 的优点</li>
</ol>
<p>提高性能：通过利用 SIMD 指令集进行并行计算，可以显著提高应用程序的性能。<br>
简化编程模型：Vector API (Sixth Incubator) 提供了一组简单易用的类和接口，使开发人员能够直接编写基于 SIMD 指令集的代码，而无需手动优化。</p>
<ol start="5">
<li>Vector API (Sixth Incubator) 的缺点</li>
</ol>
<p>平台限制：Vector API (Sixth Incubator) 的实现依赖于特定的硬件平台和操作系统，因此在不同的平台上可能存在兼容性问题。<br>
学习成本：使用 Vector API (Sixth Incubator) 需要学习新的类和接口，并理解 SIMD 指令集的工作原理，对于一些开发人员来说可能需要花费一定的时间和精力。</p>
<ol start="6">
<li>Vector API (Sixth Incubator) 的使用示例<br>
下面是一个简单的使用 Vector API (Sixth Incubator) 进行向量化计算的示例：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们创建了两个长度为 8 的浮点数向量，并执行了向量化的加法操作。最后将结果输出到数组中并打印出来。</p>
<ol start="7">
<li>Vector API (Sixth Incubator) 的使用注意事项</li>
</ol>
<p>硬件兼容性：由于 Vector API (Sixth Incubator) 的实现依赖于特定的硬件平台和操作系统，因此在使用之前需要确保目标平台支持<br>
SIMD 指令集。<br>
性能优化：虽然 Vector API (Sixth Incubator) 可以提高应用程序的性能，但要获得最佳性能还需要进行适当的优化。例如，避免频繁的向量化操作和数据拷贝等。</p>
<ol start="8">
<li>总结<br>
Vector API (Sixth Incubator) 是 Java 平台的一个项目，旨在提供一种简单且高效的方式来执行向量化计算。它基于 SIMD<br>
指令集，并通过引入新的类和接口来支持并行计算。使用 Vector API (Sixth Incubator) 可以提高应用程序的性能，但需要注意硬件兼容性和适当的性能优化。</li>
</ol>
<p>| 449: | <a href="https://openjdk.org/jeps/449" target="_blank" rel="noopener noreferrer">Deprecate the Windows 32-bit x86 Port for Removal</a> |<br>
名字太长了。。后面简称 449</p>
<ol>
<li>什么是 JEP 449?<br>
JEP 449（Java Enhancement Proposal 449）是一个针对 OpenJDK 的提案，旨在废弃并最终移除 Windows 32 位 x86 平台上的 Java<br>
支持。</li>
<li>为什么需要废弃 Windows 32 位 x86 平台上的 Java 支持？<br>
主要有以下几个原因：</li>
</ol>
<p>过时的硬件和操作系统：Windows 32 位 x86 平台已经逐渐被淘汰，现代计算机普遍采用 64 位架构。同时，大多数新版本的 Windows<br>
操作系统也只提供了 64 位版本。<br>
性能限制：32 位架构限制了可寻址内存空间的大小，导致无法充分利用现代计算机的资源。而 64 位架构可以提供更大的内存地址空间，从而提高应用程序的性能和扩展性。<br>
安全问题：32 位架构存在一些安全漏洞和限制，例如缓冲区溢出等。而 64 位架构通过引入更多的保护机制来增加应用程序的安全性。</p>
<p>基于以上原因，废弃 Windows 32 位 x86 平台上的 Java 支持是合理且必要的。</p>
<ol start="3">
<li>JEP 449 的实现原理<br>
JEP 449 的实现原理涉及到编译器、虚拟机和库等多个方面的改动。</li>
</ol>
<p>编译器层面：废弃 32 位 x86 平台上的 Java 支持需要对编译器进行修改，禁止生成 32 位 x86 架构的目标代码。<br>
虚拟机层面：虚拟机需要对内存管理、垃圾回收等进行调整，以适应 64 位架构的特性。同时，还需要更新与操作系统交互的部分代码，确保在<br>
64 位环境下正常运行。<br>
库层面：一些与硬件相关的库可能需要重新编写或者替换为 64 位版本，以充分利用 64 位架构的优势。</p>
<p>具体实现细节可以参考 JEP 449 提案中的详细说明。</p>
<ol start="4">
<li>JEP 449 的优点</li>
</ol>
<p>性能提升：64 位架构可以提供更大的内存地址空间，从而提高应用程序的性能和扩展性。<br>
安全增强：64 位架构引入了更多的保护机制，提高了应用程序的安全性。<br>
与现代计算机趋势相符：Windows 32 位 x86 平台已经逐渐被淘汰，废弃该平台上的 Java 支持是与时俱进的举措。</p>
<ol start="5">
<li>JEP 449 的缺点</li>
</ol>
<p>向后兼容性问题：废弃 Windows 32 位 x86 平台上的 Java 支持可能导致一些现有的应用程序无法在该平台上运行。这需要开发人员进行相应的迁移和调整。<br>
**对于仍然使用 32 位硬件和操作系统的用户而言，将无法继续获得新版本的 Java 更新和功能改进。</p>
<ol start="6">
<li>JEP 449 的使用示例<br>
JEP 449 是一个 OpenJDK 的提案，它主要影响到 OpenJDK 的开发者和 Windows 32 位 x86 平台上的 Java 用户。对于开发者来说，他们需要根据<br>
JEP<br>
449 的实施情况，适时地迁移和调整自己的应用程序代码。对于 Windows<br>
32 位 x86 平台上的 Java 用户来说，他们需要考虑升级到 64 位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</li>
<li>JEP 449 的使用注意事项</li>
</ol>
<p>开发者需要及时关注 JEP 449 的实施情况，并根据需要进行相应的迁移和调整。<br>
Windows 32 位 x86 平台上的 Java 用户需要考虑升级到 64 位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</p>
<ol start="8">
<li>总结<br>
JEP 449 旨在废弃并最终移除 Windows<br>
32 位 x86 平台上的 Java 支持。这是基于该平台已经逐渐被淘汰、性能限制和安全问题等原因做出的合理举措。废弃该平台上的 Java<br>
支持可以提高应用程序的性能和安全性，并与现代计算机趋势相符。开发者需要及时关注 JEP<br>
449 的实施情况，并根据需要进行相应的迁移和调整。Windows 32 位 x86 平台上的 Java 用户需要考虑升级到 64<br>
位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</li>
</ol>
<p>| 451: |<a href="https://openjdk.org/jeps/451" target="_blank" rel="noopener noreferrer">Prepare to Disallow the Dynamic Loading of Agents</a> |</p>
<ol>
<li>什么是动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of Agents）？<br>
动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of<br>
Agents）是一个 Java 增强提案，其目标是在 JVM 中禁止动态加载代理。代理是一种能够修改或监视应用程序行为的机制，它可以通过字节码注入来实现。</li>
<li>为什么需要动态加载代理禁用准备？<br>
动态加载代理允许开发人员在运行时修改和监视 Java<br>
应用程序的行为。虽然这对于调试和性能分析等方面非常有用，但也存在潜在的安全风险。恶意代码可能会利用动态加载代理的功能来执行恶意操作，例如窃取敏感信息、篡改数据等。<br>
因此，为了加强 Java 应用程序的安全性，限制动态加载代理的使用是很有必要的。</li>
<li>动态加载代理禁用准备的实现原理<br>
动态加载代理禁用准备的实现涉及到以下几个方面：<br>
3.1 修改 ClassLoader<br>
该提案建议修改 Java 虚拟机的类加载器，以阻止动态加载代理。具体而言，将在java.lang.ClassLoader<br>
类中添加一个新的方法boolean disallowDynamicAgentLoading()，默认返回false。当该方法被调用时，将返回true，表示禁止动态加载代理。<br>
3.2 修改 Instrumentation API<br>
为了支持 ClassLoader 的修改，还需要对 Java 虚拟机的 Instrumentation<br>
API 进行相应的更改。具体而言，将在java.lang.instrument.Instrumentation<br>
接口中添加一个新的方法boolean isDynamicAgentLoadingAllowed()，默认返回true。当该方法返回false时，表示禁止动态加载代理。<br>
3.3 更新安全管理器<br>
此外，还建议更新 Java 虚拟机的安全管理器（SecurityManager），以允许检查是否允许动态加载代理。这样可以通过安全策略来控制哪些代码可以使用动态加载代理功能。</li>
<li>动态加载代理禁用准备的优点</li>
</ol>
<p>提高 Java 应用程序的安全性：禁止动态加载代理可以防止恶意代码利用其功能执行潜在的危险操作。<br>
简化安全配置：通过更新安全管理器和类加载器，可以更方便地控制动态加载代理的使用权限，简化安全配置过程。</p>
<ol start="5">
<li>动态加载代理禁用准备的缺点</li>
</ol>
<p>可能影响现有代码：如果现有代码依赖于动态加载代理的功能，那么禁用它可能会导致这些代码无法正常工作。因此，在应用该增强提案之前，需要仔细评估现有代码的依赖关系。</p>
<ol start="6">
<li>动态加载代理禁用准备的使用示例<br>
以下是一个简单的示例，展示了如何使用动态加载代理禁用准备：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，premain方法是 Java 代理的入口点。通过调用isDynamicAgentLoadingAllowed()方法，可以检查是否允许动态加载代理。如果不允许，则抛出安全异常。</p>
<ol start="7">
<li>动态加载代理禁用准备的使用注意事项</li>
</ol>
<p>在使用动态加载代理禁用准备之前，需要仔细评估现有代码是否依赖于动态加载代理的功能。<br>
需要更新相关的类加载器和安全管理器来支持禁止动态加载代理的功能。<br>
使用动态加载代理禁用准备时，需要确保应用程序的安全策略能够正确地控制动态加载代理的使用权限。</p>
<ol start="8">
<li>总结<br>
动态加载代理禁用准备是一个 Java 增强提案，旨在禁止动态加载代理以提高应用程序的安全性。它通过修改类加载器、Instrumentation<br>
API 和安全管理器来实现禁止动态加载代理的功能。尽管这样做可以增加应用程序的安全性，但也可能影响依赖于动态加载代理的现有代码。因此，在使用该功能之前需要仔细评估现有代码的依赖关系。</li>
</ol>
<p>| 452: | <a href="https://openjdk.org/jeps/452" target="_blank" rel="noopener noreferrer">Key Encapsulation Mechanism API</a> |</p>
<ol>
<li>什么是 Key Encapsulation Mechanism API?<br>
Key Encapsulation Mechanism (KEM) API 是一个 Java<br>
API，用于支持密钥封装机制。密钥封装是一种加密技术，它将一个对称密钥（也称为会话密钥）与公钥结合使用，以便在不直接暴露私钥的情况下安全地传输密钥。<br>
KEM API 提供了一组方法和类，用于生成、封装和解封装密钥。它可以与现有的密码学算法和协议集成，提供更高级别的密钥管理功能。</li>
<li>为什么需要 Key Encapsulation Mechanism API?<br>
在传统的密钥交换过程中，通常需要事先共享或分发密钥。这可能存在许多安全风险，例如密钥泄露、中间人攻击等。而密钥封装机制通过使用公钥进行密钥交换，避免了这些问题。<br>
Key Encapsulation Mechanism API 的出现使得开发者能够更方便地实现密钥封装机制，并提供了更高级别的密钥管理功能。它简化了密钥生成、封装和解封装的过程，同时保证了安全性和可靠性。</li>
<li>Key Encapsulation Mechanism API 的实现原理<br>
Key Encapsulation Mechanism API 的实现原理基于非对称加密算法和密钥封装机制。它使用公钥进行密钥交换，并通过将会话密钥封装在一个安全的密文中，以确保密钥的安全传输。<br>
具体实现过程如下：</li>
</ol>
<p>生成一对公私钥对。<br>
使用公钥进行密钥封装，生成一个密文。<br>
将密文发送给接收方。<br>
接收方使用私钥解封装密文，得到会话密钥。<br>
双方可以使用会话密钥进行加密通信。</p>
<ol start="4">
<li>Key Encapsulation Mechanism API 的优点</li>
</ol>
<p>安全性高：Key Encapsulation Mechanism API 使用了非对称加密算法和密钥封装机制，能够提供较高的安全性，避免了密钥泄露和中间人攻击等问题。<br>
易于使用：API 提供了简单易用的方法和类，开发者可以轻松地生成、封装和解封装密钥，无需深入了解底层算法和协议。<br>
灵活性强：API 可以与现有的密码学算法和协议集成，提供更高级别的密钥管理功能，满足不同场景的需求。</p>
<ol start="5">
<li>Key Encapsulation Mechanism API 的缺点</li>
</ol>
<p>依赖于非对称加密算法：Key Encapsulation Mechanism API 的实现依赖于非对称加密算法，这些算法可能存在性能上的瓶颈和限制。<br>
需要保护私钥的安全：由于使用了非对称加密算法，私钥的安全至关重要。开发者需要采取措施来保护私钥的机密性和完整性。</p>
<ol start="6">
<li>Key Encapsulation Mechanism API 的使用示例<br>
下面是一个简单的使用示例，演示了如何使用 Key Encapsulation Mechanism API 进行密钥封装和解封装：</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7">
<li>Key Encapsulation Mechanism API 的使用注意事项</li>
</ol>
<p>开发者需要选择合适的非对称加密算法和密钥封装机制，根据具体需求进行配置。<br>
私钥的安全至关重要，开发者应该采取措施来保护私钥的机密性和完整性。<br>
密钥封装过程中生成的密文需要通过安全信道传输，以确保密钥的安全性。</p>
<ol start="8">
<li>总结<br>
Key Encapsulation Mechanism API 是一个用于支持密钥封装机制的 Java<br>
API。它提供了一组方法和类，用于生成、封装和解封装密钥。通过使用公钥进行密钥交换，避免了传统密钥交换方式中存在的安全风险。API<br>
的实现原理基于非对称加密算法和密钥封装机制，能够提供较高的安全性和灵活性。开发者可以轻松地使用 API<br>
进行密钥封装和解封装操作，并与现有的密码学算法和协议集成，满足不同场景的需求。然而，API 的使用需要注意私钥的安全性和密文的传输安全。</li>
</ol>
<p>| 453: | <a href="https://openjdk.org/jeps/453" target="_blank" rel="noopener noreferrer">Structured Concurrency (Preview)</a> |<br>
什么是结构化并发（Structured Concurrency）？<br>
结构化并发是一种用于简化并发编程的 API。它将在不同线程中运行的相关任务组视为一个单独的工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。<br>
为什么需要结构化并发？<br>
传统的并发编程模型，如ExecutorService<br>
API，由于其无限制的并发模式，引入了复杂性和风险。这些模型没有强制执行或跟踪任务和子任务之间的关系，使得管理和观察并发任务变得困难。结构化并发模型认为任务结构应该反映代码结构，在单线程代码中，执行总是强制实施任务和子任务的层次结构，每个子任务的生命周期相对于其他子任务受到代码的语法块结构的控制。<br>
结构化并发旨在消除与并发编程相关的常见风险，例如线程泄漏和取消延迟，并增强并发代码的可观察性。<br>
结构化并发的实现原理<br>
结构化并发通过引入新的 API 来实现，其中最重要的类是StructuredTaskScope。StructuredTaskScope<br>
封装了一组相关的任务，这些任务应该一起完成，如果任何子任务失败，则会取消剩余的子任务。<br>
在结构化并发中，使用StructuredTaskScope<br>
创建一个作用域，在该作用域内可以派生出多个子任务。这些子任务将被视为整体，并且它们之间存在依赖关系。当所有子任务完成后，可以对它们进行处理，例如获取结果或抛出异常。<br>
结构化并发的优点</p>
<p>简化并发编程：结构化并发提供了一种更简单、更直观的方式来处理并发任务。<br>
错误处理和取消操作：通过将相关任务组合成一个单元，结构化并发使错误处理和取消操作更加容易和可靠。<br>
提高可靠性：结构化并发模型消除了常见的风险，如线程泄漏和取消延迟，从而提高了并发代码的可靠性。<br>
增强可观察性：结构化并发模型使得观察并发任务的执行状态变得更加方便。</p>
<p>结构化并发的缺点</p>
<p>预览功能：目前，结构化并发仍处于预览阶段，需要启用预览功能才能使用。</p>
<p>结构化并发的使用示例<br>
下面是一个使用结构化并发的示例代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，我们创建了一个新的StructuredTaskScope作用域，并使用它派生了两个子任务：一个执行findUser()<br>
方法，另一个执行fetchOrder()方法。一旦两个子任务都完成，就可以使用它们的结果创建一个新的Response对象。<br>
结构化并发的使用注意事项</p>
<p>结构化并发是一个预览功能，默认情况下被禁用。要使用StructuredTaskScope API，开发人员必须启用预览功能来编译代码。<br>
使用结构化并发时，通常不直接使用StructuredTaskScope<br>
类，而是使用实现关闭策略的两个子类之一。这些子类分别是ShutdownOnFailure和ShutdownOnSuccess，支持当第一个子任务失败或成功时关闭作用域的模式。<br>
运行结构化并发程序时，需要使用--enable-preview选项启用预览功能。</p>
<p>总结<br>
结构化并发是一种用于简化并发编程的 API，它将相关任务组合成一个单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。通过引入StructuredTaskScope<br>
类和相关的子类，结构化并发提供了一种更简单、更直观的方式来处理并发任务。然而，需要注意的是，结构化并发目前仍处于预览阶段，并且需要启用预览功能才能使用。<br>
JDK 21 将是大多数供应商的长期支持 （LTS） 版本。有关自上一个 LTS 版本 JDK 17 以来集成的 JEP<br>
的完整列表，请参阅 here.<br>
Schedule</p>
<table>
<thead>
<tr>
<th>发布时间</th>
<th>发布内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>2023/06/08</td>
<td><a href="https://openjdk.org/jeps/3#rdp-1" target="_blank" rel="noopener noreferrer">第一阶段缓慢降级（从主分支派生）</a></td>
</tr>
<tr>
<td>2023/07/20</td>
<td><a href="https://openjdk.org/jeps/3#rdp-2" target="_blank" rel="noopener noreferrer">第二阶段缓慢降级</a></td>
</tr>
<tr>
<td>2023/08/10</td>
<td><a href="https://openjdk.org/jeps/3#rc" target="_blank" rel="noopener noreferrer">初始候选发行版</a></td>
</tr>
<tr>
<td>2023/08/24</td>
<td><a href="https://openjdk.org/jeps/3#rc" target="_blank" rel="noopener noreferrer">最终候选发行版</a></td>
</tr>
<tr>
<td>2023/09/19</td>
<td>正式发布</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>内网穿透-ngrok</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/develop/network/ngrok.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/develop/network/ngrok.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">内网穿透-ngrok</source>
      <description>什么叫做内网穿透 首先，我们生活中的网络分为内网和外网 内网: 内网就是我们自己的网络环境，就你自己能够访问的，比如说你自己的的本地: localhost 外网: 外网就不言而喻了，你看网页，视频等这些网址都是外网 那么什么叫做内网穿透呢，简单点来说，就是通过访问到外网的地址，然后穿透到你的内网地址 内网穿透又叫端口映射，用一句最简单的话来讲就是：将你的计算机所连接的私有网络映射到公网上，别人通过你给的域名或ip即可访问你本地的服务。 ngrok简介</description>
      <category>内网穿透</category>
      <pubDate>Thu, 28 Sep 2023 07:37:08 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么叫做内网穿透</h2>
<p>首先，我们生活中的网络分为内网和外网</p>
<p>内网: 内网就是我们自己的网络环境，就你自己能够访问的，比如说你自己的的本地: localhost</p>
<p>外网: 外网就不言而喻了，你看网页，视频等这些网址都是外网</p>
<p>那么什么叫做内网穿透呢，简单点来说，就是通过访问到外网的地址，然后穿透到你的内网地址</p>
<blockquote>
<p>内网穿透又叫端口映射，用一句最简单的话来讲就是：将你的计算机所连接的私有网络映射到公网上，别人通过你给的域名或ip即可访问你本地的服务。</p>
</blockquote>
<h2> ngrok简介</h2>
<blockquote>
<p>个人认为最好用的，那就是：ngrok 。只需要一行命令就能帮你轻松实现内网穿透！</p>
</blockquote>
<p>ngrok 是一个反向代理，通过在公共端点和本地运行的 Web 服务器之间建立一个安全的通道，实现内网主机的服务可以暴露给外网。 ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放，所以ngrok可以很方便地协助服务端程序测试。</p>
<h2> 特点</h2>
<ul>
<li>官方维护,一般比较稳定</li>
<li>跨平台,非开源</li>
<li>有流量记录和重发功能</li>
</ul>
<h2> 注册登录账号</h2>
<p>从官网（<a href="https://ngrok.com/%EF%BC%89" target="_blank" rel="noopener noreferrer">https://ngrok.com/）</a> 右上角 Sign Up 进入，完成庄户注册。如果有GitHub账号的，直接GitHub授权登录，快得很！<br>
完成注册并登录之后，可以看到Dashboard中就给出了使用的三个步骤：</p>
<ul>
<li>主页面  <div align="center">
  <img src="/images/network/01-home.png" style="zoom:30%;" alt="ngrok主页面">
  </div>
</li>
<li>登录页面  <div align="center">
  <img src="/images/network/02-login.png" style="zoom:30%;" alt="ngrok主页面">
  </div>
</li>
</ul>
<p><code>注:</code> </p>
<ul>
<li>完成登录后-Dashboard页面  <div align="center">
  <img src="/images/network/03-img.png" style="zoom:30%;" alt="Dashboard页面">
  </div>
</li>
</ul>
<h2> 安装Ngrok</h2>
<ul>
<li>
<p>进入官网/Dashboard 页面下载与操作系统相匹配的版本</p>
<ul>
<li>macOS</li>
<li>Linux</li>
<li>Windows</li>
<li>freeBSD</li>
</ul>
</li>
<li>
<p>官方给出了每个操作系统的安装方式，很良心，直接访问官网按照官网的步骤操作即可</p>
</li>
<li>
<p>个人推荐直接下载ZIP包，然后直接解压，这种方式最为迅速！</p>
</li>
<li>
<p>下面以macos为列，进行配置安装</p>
<ul>
<li>安装</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<h2> 配置账户</h2>
<p>直接复制Dashboard中第二步的ngrok config add-authtoken xxxxx命令，然后打开终端，定位到之前解压ngrok的位置执行它！</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>
<p>终端会输出为你保存的配置路径(macos)</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>启动ngrok<br>
执行命令启动内网穿透：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<p>这里没用dashboard的80端口，用了其他的端口，如果你本地的服务用了其他端口，记得修改一下就可以了。</p>
<p>此时，终端也变了一副画面，具体如下：</p>
  <div align="center">
      <img src="/images/network/04-img.png" style="zoom:80%;" alt="启动窗口">
  </div>
]]></content:encoded>
    </item>
    <item>
      <title>Linux</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/services/Linux.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/services/Linux.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">Linux</source>
      <description>1、关机、重启 # 关机 shutdown -h now # 重启 shutdown -r now</description>
      <category>Linux</category>
      <pubDate>Wed, 27 Sep 2023 07:57:22 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 1、关机、重启</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、查看系统,CPU信息</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、建立软连接</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4、rpm相关</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、命令重命名</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 6、同步服务器时间</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 7、后台运行命令</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8、强制活动用户退出</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 9、查看命令路径</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 10、查看进程所有打开最大fd数</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 11、配置dns</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 12、nslookup,查看域名路由表</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 13、last, 最近登录信息列表</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 14、设置固定ip</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 查看进程内加载的环境变量</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>macOS</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/services/Macos.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/services/Macos.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">macOS</source>
      <description>Macos macos鼠标卡顿问题 # 这个命令会查看当前鼠标移动速度 defaults read -g com.apple.mouse.scaling # 这个命令是设置默认鼠标移动速度我设置的是5 defaults write -g com.apple.mouse.scaling 5</description>
      <category>macOS</category>
      <pubDate>Wed, 27 Sep 2023 07:57:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Macos</h2>
<h3> macos鼠标卡顿问题</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 刷新缓存</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 环境变量</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 基本命令</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>学习</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/home.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/home.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">学习</source>
      <pubDate>Wed, 27 Sep 2023 07:57:06 GMT</pubDate>
    </item>
    <item>
      <title>算法</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/code/algorithm.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/code/algorithm.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">算法</source>
      <description>判断重复元素 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。 数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 public class Demo01 { public static void main(String[] args) { // 定义一个数组 int[] arr = {1, 2, 4, 5, 6, 3, 5, 6, 3, 4}; ArrayList&amp;lt;Integer&amp;gt; list = compare(arr); System.out.println(list); } public static ArrayList&amp;lt;Integer&amp;gt; compare(int[] arr) { HashMap&amp;lt;Integer, Integer&amp;gt; hashMap = new HashMap&amp;lt;Integer, Integer&amp;gt;(arr.length); // 定义一个map集合 for (int i : arr) { // 首先判断map集合中进行的key是否为null，如果不为nul的话进行添加的操作 if (hashMap.get(i) != null) { hashMap.put(i, hashMap.get(i) + 1); } else { // 如果key的值为null的话，将value的值置为1 hashMap.put(i, 1); } } ArrayList&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); // 遍历map，将value值大于1的key取出 Set&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; entries = hashMap.entrySet(); for (Map.Entry&amp;lt;Integer, Integer&amp;gt; entry : entries) { if (entry.getValue() &amp;gt; 1) { Integer key = entry.getKey(); list.add(key); } } return list; } }</description>
      <category>算法</category>
      <pubDate>Wed, 27 Sep 2023 07:56:49 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 判断重复元素</h3>
<blockquote>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。<br>
数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 快速排序</h3>
<blockquote>
<p>快速排序由于其时间复杂度优于大部分的排序算法，因而命名为快速排序。快速排序实现的核心思想就是在待排序序列中选择一个基准值，然后将小于基准值的数字放在基准值左边，大于基准值的数字放在基准值右边，然后左右两边递归排序，整个排序过程中最关键部分就是寻找基准值在待排序序列中的索引位置。</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 冒泡排序</h3>
<blockquote>
<p>冒泡排序是一种计算机科学领域的较简单的排序算法，它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序错误就把他们交换过来，走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 二分法</h3>
<blockquote>
<p>即一分为二的的方法。对于在区间[a,b]上连续不断且满足f(a)*f(b)&lt;0的函数y=f(x),通过不断地把函数f(x)的零点所在区间二等分，使区间两个端点逐步逼近零点，进而得到零点的近似值的方法。</p>
</blockquote>
<p><code>tip:</code> 说人话：把答案所在的区间逐渐缩小，直到区间内只有答案。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>自动化部署git项目</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/deploy/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/deploy/%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">自动化部署git项目</source>
      <description>自动化部署git项目 创建部署脚本 #!/usr/bin/env sh # 确保脚本抛出遇到的错误 set -e # 生成静态文件 npm run build # 进入生成的文件夹 cd docs/.vuepress/dist # 如果是发布到自定义域名 # echo &amp;apos;www.yourwebsite.com&amp;apos; &amp;gt; CNAME git init git add -A git commit -m &amp;apos;message&amp;apos; # 如果发布到 https://&amp;lt;USERNAME&amp;gt;.github.io git push -f git@github.com:wangfeng1996/wangfeng1996.github.io.git master # 如果发布到 https://USERNAME.github.io/&amp;lt;REPO&amp;gt; REPO=github上的项目 # git push -f git@github.com:USERNAME/&amp;lt;REPO&amp;gt;.git master:gh-pages cd ../ &amp;amp;&amp;amp; rm -rf dist</description>
      <category>shell</category>
      <pubDate>Tue, 26 Sep 2023 09:35:15 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 自动化部署git项目</h1>
<h2> 创建部署脚本</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 添加命令(package.josn)</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>tip:</code> 如果不添加这个脚本，直接在控制台输入 <code>bash deploy.sh</code> 即可</p>
<h2> 运行发布命令</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Homebrew</title>
      <link>https://theme-hope.vuejs.press/zh/config/theme/layout.html/develop/homebrew/Homebrew.html</link>
      <guid>https://theme-hope.vuejs.press/zh/config/theme/layout.html/develop/homebrew/Homebrew.html</guid>
      <source url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/rss.xml">Homebrew</source>
      <description>Homebrew 使用指南 对于习惯了使用命令来完成一切的程序员来说，安装软件这种小事，自然是能够用命令解决，就不用图形界面选择。但是在 Linux 中，我们有 yum、apt、dnf、pkg等命令来完成软件的安装，macOS 却并未为我们提供一个好用的包管理器，帮助我们更好的使用 macOS。 好在，虽然官方没有提供，我们却可以使用 Homebrew 这一神器，来完成类似的工作，就如同 Homebrew 的 Slogan ：“The missing package manager for macOS (or Linux)”</description>
      <category>homebrew</category>
      <pubDate>Tue, 26 Sep 2023 09:35:15 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Homebrew 使用指南</h1>
<p>对于习惯了使用命令来完成一切的程序员来说，安装软件这种小事，自然是能够用命令解决，就不用图形界面选择。但是在 Linux<br>
中，我们有 <code>yum</code>、<code>apt</code>、<code>dnf</code>、<code>pkg</code>等命令来完成软件的安装，macOS 却并未为我们提供一个好用的包管理器，帮助我们更好的使用<br>
macOS。</p>
<p>好在，虽然官方没有提供，我们却可以使用 <strong>Homebrew</strong> 这一神器，来完成类似的工作，就如同 Homebrew 的 Slogan ：“The missing<br>
package manager for macOS (or Linux)”</p>
<h2> 一、Homebrew介绍</h2>
<p>Homebrew 由开发者 Max Howell 开发，并基于 BSD 开源，是一个非常方便的包管理器工具。在早期， Homebrew 仅有 macOS<br>
的版本，后续随着用户的增多，Homebrew 还提供了 Linux 的版本，帮助开发者在 Linux 同样使用 Homebrew 来配置环境。</p>
<h2> 二、Homebrew 的几个核心概念</h2>
<p>在正式介绍 Homebrew 的使用之前，我先为你介绍一下 Homebrew 中的一些核心的概念，了解这些概念，就可以帮助你更好的去使用<br>
Homebrew。</p>
<table>
<thead>
<tr>
<th style="text-align:left">词汇</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">formula (e)</td>
<td style="text-align:left">安装包的描述文件，formulae 为复数</td>
</tr>
<tr>
<td style="text-align:left">cellar</td>
<td style="text-align:left">安装好后所在的目录</td>
</tr>
<tr>
<td style="text-align:left">keg</td>
<td style="text-align:left">具体某个包所在的目录，keg 是 cellar 的子目录</td>
</tr>
<tr>
<td style="text-align:left">bottle</td>
<td style="text-align:left">预先编译好的包，不需要现场下载编译源码，速度会快很多；官方库中的包大多都是通过 bottle 方式安装</td>
</tr>
<tr>
<td style="text-align:left">tap</td>
<td style="text-align:left">下载源，可以类比于 Linux 下的包管理器 repository</td>
</tr>
<tr>
<td style="text-align:left">cask</td>
<td style="text-align:left">安装 macOS native 应用的扩展，你也可以理解为有图形化界面的应用。</td>
</tr>
<tr>
<td style="text-align:left">bundle</td>
<td style="text-align:left">描述 Homebrew 依赖的扩展</td>
</tr>
</tbody>
</table>
<p>其中，最关键的是 tap 、cask，我们在后续会经常用到。</p>
<h2> 三、Homebrew 常用操作</h2>
<h3> 1、要求</h3>
<ul>
<li>64-bit Intel CPU 或者 Apple Silicon CPU(苹果自己研发的CPU)</li>
<li>macOS版本为Mojave（10.14）或者以上</li>
<li>Xcode命令行工具（安装Command Line Tools）<br>
<code>安装xcode命令</code><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>支持shell (zsh或者bash) 在macOS 10.15 之后 默认shell是zsh<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> 2、安装</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、卸载</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong><code>tip:</code></strong> Homebrew 会将软件包安装到独立目录，并将其文件软链接至 <code>/usr/local</code></p>
<h3> 4、安装软件</h3>
<blockquote>
<p>当你完成了 Homebrew 以后，就可以使用 Homebrew<br>
来完成软件的安装了，安装命令行软件的时候非常简单，只需要执行 <code>brew install [软件名]</code> 就可以安装软件了，比如说，我们要安装<br>
wget，那么只需要执行 <code>brew install wget</code> 就可以了。</p>
</blockquote>
<h3> 5、搜索软件</h3>
<blockquote>
<p>很多时候，我们不知道自己想要的软件是否有，或者说具体的名字是什么，这个时候你有两种方式来完成搜索</p>
</blockquote>
<h4> 5.1 使用命令搜索</h4>
<p>在命令行中，你可以直接使用 <code>brew search [关键词]</code> 来进行搜索<br>
<img src="/images/homebrew/homebrew-01.png" alt="搜索软件" loading="lazy"></p>
<p><strong><code>tip:</code></strong> 命令行搜索软件 输入你想要的关键词，来搜索即可得到结果。 在搜索时应当遵循宁可少字，不能错字的原则来搜索。</p>
<h4> 5.2 使用网页搜索</h4>
<blockquote>
<p>除了使用命令行搜索以外，你可以使用网页端的搜索工具来辅助你进行搜索。在 Homebrew 的官网，你可以找到 formulae<br>
的链接，或者直接访问 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fformulae.brew.sh%2F" target="_blank" rel="noopener noreferrer">https://formulae.brew.sh/</a><br>
来进行搜索。你只需要在界面的输入框中输入你要搜索的命令，然后就会出现对应的候选命令</p>
</blockquote>
<figure><img src="/images/homebrew/homebrew-03.png" alt="搜索软件" tabindex="0" loading="lazy"><figcaption>搜索软件</figcaption></figure>
<p><strong><code>tip:</code></strong> 选择其中你要使用的那个，点击就会进入到软件的介绍页面</p>
<figure><img src="/images/homebrew/homebrew-02.png" alt="查看软件介绍" tabindex="0" loading="lazy"><figcaption>查看软件介绍</figcaption></figure>
<p><strong><code>tip:</code></strong> 你就可以看到 Homebrew 中的软件具体信息。</p>
<h3> 6、查看已经安装的包</h3>
<p>如果你想要查看你都安装了哪些包，你可以执行 <code>brew list</code> 命令，来查看所有你已经安装的软件。<br>
<img src="/images/homebrew/homebrew-04.png" alt="查看所有软件" loading="lazy"></p>
<h3> 7、更新一个已经安装的包</h3>
<blockquote>
<p>我们安装的软件并不会自动更新，因此，我们可以根据自己的需求，批量更新软件，或者更新单个软件。<br>
你可以先使用 <code>brew outdated</code> 来查看所有有更新版本的软件。<br>
然后使用 <code>brew upgrade</code> 来更新所有的软件，或者是使用 <code>brew upgrade [软件名]</code>来更新单个软件。</p>
</blockquote>
<figure><img src="/images/homebrew/homebrew-05.png" alt="查看需要更新的软件" tabindex="0" loading="lazy"><figcaption>查看需要更新的软件</figcaption></figure>
<h3> 8、卸载某个已经安装的包</h3>
<p>如果你想要卸载某个包，你可以执行 <code>brew uninstall [软件名]</code> 来卸载一个特定的软件，比如卸载 wget 是这样的。<br>
<img src="/images/homebrew/homebrew-06.png" alt="卸载某个已经安装的包" loading="lazy"></p>
<h3> 9、查看包的信息</h3>
<p>如果你想要查看某个特定软件的信息，你可以执行命令 <code>brew info [软件名]</code> 来查看该软件的详情。<br>
<img src="/images/homebrew/homebrew-07.png" alt="查看包的信息" loading="lazy"></p>
<h3> 10、清理软件的旧版</h3>
<blockquote>
<p>Homebrew 用久了，会有一些历史版本的软件遗留在系统里，这个时候，你可以使用 <code>brew cleanup</code><br>
命令来清理系统中所有软件的历史版本，或者可以使用 <code>brew cleanup [软件名]</code>来清理特定软件的旧版。<br>
<img src="/images/homebrew/homebrew-08.png" alt="清理软件的旧版" loading="lazy"></p>
</blockquote>
<h3> 11、常用命令</h3>
<h4> 11.1 管理后台软件命令</h4>
<blockquote>
<p>诸如 Nginx、MySQL 等软件，都是有一些服务端软件在后台运行，如果你希望对这些软件进行管理，可以使用 <code>brew services</code> 命令来进行管理</p>
</blockquote>
<ul>
<li><code>brew services list</code>: 查看所有服务</li>
<li><code>brew services run [服务名]</code>: 单次运行某个服务</li>
<li><code>brew services start [服务名]</code>: 运行某个服务，并设置开机自动运行。</li>
<li><code>brew services stop [服务名]</code>：停止某个服务</li>
<li><code>brew services restart</code>：重启某个服务</li>
</ul>
<h4> 11.2 其他命令</h4>
<ul>
<li><code>brew -v</code>: 查看homebrew版本</li>
<li><code>brew list</code>: 查看已安装的包</li>
<li><code>brew install packageName</code>: 安装某个软件</li>
<li><code>brew uninstall packageName</code>: 卸载某个软件</li>
<li><code>brew searck packageName</code>: 查找某个软件</li>
<li><code>brew info packageName</code>: 查看软件包的信息</li>
<li><code>brew update</code>: 更新homebrew</li>
<li><code>brew doctor</code>: 诊断homebrew</li>
<li><code>brew -h</code>: 查看帮助信息</li>
<li><code>brew cleanup</code>: 清理旧版本</li>
<li><code>brew upgrade </code>: 全部更新</li>
<li><code>brew upgrade packageName</code>: 更新指定包</li>
<li><code>brew outdated</code>: 查询可更新的包</li>
<li><code>brew install --cask packageName</code>: 安装 macOS 应用程序、字体和插件以及其他非开源软件</li>
<li><code>brew uninstall --cask packageName</code>: 卸载 macOS 应用程序、字体和插件以及其他非开源软件</li>
<li><code>brew tap</code>: 列出当前的存储库</li>
</ul>
<h3> 12、检查 Hombrew 环境</h3>
<blockquote>
<p>如果你的 Hombrew 没有办法正常的工作，你可以执行 <code>brew doctor</code> 来开启 Homebrew 自带的检查，从而确认有哪些问题，并进行修复。</p>
</blockquote>
<figure><img src="/images/homebrew/homebrew-09.png" alt="检查 Hombrew 环境" tabindex="0" loading="lazy"><figcaption>检查 Hombrew 环境</figcaption></figure>
<h3> 13、更新 Homebrew</h3>
<blockquote>
<p>Homebrew 经常会在执行命令的时候触发更新，不过如果你想要主动检查更新，可以执行 <code>brew update</code> 来唤起 Homebrew 的更新。</p>
</blockquote>
<h3> 14、tap命令</h3>
<blockquote>
<p>homebrew 官方在安装的时候会有一些 tap 但是在使用时，依然会需要安装一些特殊的 tap ，这个时候，我们就要用到 tap 的命令来添加新的tap</p>
</blockquote>
<h4> 14.1 添加tap</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 14.2 常用 tap</h4>
<blockquote>
<p>在使用 homebrew 时，我们一般会添加几个常用的 tap，来确保我们有足够的软件来安装。</p>
</blockquote>
<ul>
<li>Caskroom</li>
</ul>
<blockquote>
<p>Caskroom 是 Homebrew 下一个非常出名的 tap ，有了 caskroom，我们就可以安装一些有图形化界面的软件了，比如 VSCode、Typora<br>
等软件。<br>
使用起来也非常简单，最新版 Homebrew 中，你可以直接使用 <code>brew cask install [软件名]</code> 来安装特定的软件，homebrew<br>
会自动安装Caskroom。</p>
</blockquote>
<ul>
<li>homebrew-cask-fonts</li>
</ul>
<blockquote>
<p>1、程序员难免要安装一些代码字体，这样才能更好的写代码，Homebrew 也提供了方便我们安装字体的tap。<br>
2、在使用时，你需要先添加对应的 tap ，然后执行安装即可了，比如我们要安装 source code pro，只需要执行如下命令。</p>
</blockquote>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 四、使用技巧</h2>
<h3> 1、切换国内的镜像源</h3>
<blockquote>
<p>Homebrew 默认使用的是国外的源，在下载时速度可能会比较慢。好在国内的清华大学和中科大提供了Homebrew的镜像源，我们可以很轻松的切换源，从而提升我们的下载速度。</p>
</blockquote>
<h4> 1.1 使用中科大的镜像</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 1.2 使用清华大学的镜像</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2、使用 Brewfile 完成环境迁移</h3>
<blockquote>
<p>1、设备永久了，我们的电脑中会有大量的软件，如果你需要迁移环境，重新安装会是一个大麻烦，好在 Homebrew<br>
本身为我们提供了一个非常好用的环境迁移的工具 —— Homebrew Bundle<br>
2、你首先需要在之前的电脑中执行 <code>brew bundle dump</code> 来完成当前环境的导出,导出完成后，你会得到一个 <em>Brewfile</em>。</p>
</blockquote>
<figure><img src="/images/homebrew/homebrew-10.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p><strong>注意：:</strong> 然后将 <em>Brewfile</em> 复制到新的电脑中，并执行 <code>brew bundle</code> 来开始安装的过程。</p>
<h3> 3、 使用网页搜索 Caskroom 的软件</h3>
<blockquote>
<p>Brew Caskroom 并没有提供搜索的命令，不过我们可以借助一些网站来进行搜索，一个是 Homebrew 官方的 Caskrrom</p>
</blockquote>
<p>页面：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fformulae.brew.sh%2Fcask%2F" target="_blank" rel="noopener noreferrer">https://formulae.brew.sh/cask/</a></p>
<figure><img src="/images/homebrew/homebrew-11.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>
<p>在这个页面，你可以看到所有被收录的页面，在命令行中输入对应的软件就可以安装了。</p>
<p>你也可以访问 <a href="https://macappstore.org/" target="_blank" rel="noopener noreferrer">http://macappstore.org/，在网站中输入你要安装的软件，点击搜索，在弹出的页面中，查看安装指南即可。</a><br>
<img src="/images/homebrew/homebrew-12.png" alt="img" loading="lazy"></p>
<h3> 4、 辅助软件</h3>
<blockquote>
<p>除了命令行，还有两款软件可以帮助我们更好的使用 Homebrew ，他们分别是 Cakebrew 和 launchrocket。</p>
</blockquote>
<ul>
<li>Cakebrew</li>
</ul>
<blockquote>
<p>Cakebrew 是 Homebrew 的 GUI 管理器，在 Cakebrew 中，你可以看到当前所有已经安装的软件，并可以在 Caskbrew 中对其他软件执行升级等操作。</p>
</blockquote>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>tip:</strong> 安装完成后，在 LaunchPad 中打开即可。</p>
<ul>
<li>launchrocket</li>
</ul>
<blockquote>
<p>launchrocket 可以用于管理 Homebrew 安装的服务，在使用时，你需要先添加对应的tap，然后再安装软件。</p>
</blockquote>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>tip:</strong> 安装完成后，在 LaunchPad 中打开即可。</p>
<h2> 五、安装配置开发环境</h2>
<h3> 1、JDK安装</h3>
<blockquote>
<p>使用HomeBrew推荐Adoptium提供的包</p>
</blockquote>
<p><a href="https://adoptium.net/zh-CN/docs/" target="_blank" rel="noopener noreferrer">安装网站：Adoptium</a></p>
<ul>
<li>搜索软件(输入)</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>输出</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>安装指定版本 1.8</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>安装指定版本 17</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>配置环境变量（在.zshrc添加下面几行）</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>Mac 下的 Java 版本管理工具 Jenv
<blockquote>
<p>jEnv是一个命令行工具，正如它的官网所宣称的那样，它是来让你忘记怎么配置JAVA_HOME环境变量的神队友。使用简单的命令就可以在不同的Java版本之间进行切换。<br>
<a href="https://www.jenv.be/" target="_blank" rel="noopener noreferrer">Jenv官网</a>    &nbsp; &nbsp; &nbsp; &nbsp;    <a href="https://github.com/jenv/jenv" target="_blank" rel="noopener noreferrer">GitHub地址</a></p>
</blockquote>
<ul>
<li>使用homebrew安装jenv<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>jenv配置环境<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>安装jenv成功后,添加需要管理的JDK
<ul>
<li>查看已安装的JDK版本本地存储路径<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>输出<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>jenv添加需要管理的本地路径<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>诊断jenv是否配置成功
<ul>
<li>输入<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>输出<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>查看添加到jenv的JDK版本<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>删除添加到jenv的JDK版本<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>jEnv配置全局的jdk版本（推荐使用）<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>配置本地版本（每个目录）<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>配置shell实例版本（当前shell）<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>启用maven插件<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>停用maven插件<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>查看当前版本的引用位置<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>其他注意点
<ul>
<li>jenv只改变了java -version的版本</li>
<li>/usr/libexec/java_home 的版本自动默认使用最高版本</li>
</ul>
</li>
<li>修改/usr/libexec/java_home的指向版本
<ul>
<li>打开java jdk安装路径中的plist配置文件：<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>修改标签JVMVersion
<ul>
<li>需要改为比其他的jdk版本好，如当前版本为17.0.10，可修改为 1.8.0.281</li>
<li>终端再次执行/usr/libexec/java_home命令，发现已修改成功：<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3> 2、maven的安装</h3>
<ul>
<li>brew查找maven版本</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>安装</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>maven在zsh环境变量配置，安装完了有提示的，直接复制就行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>查看是否安装成功</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3、git的安装</h3>
<ul>
<li>brew 查找git版本</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>brew 安装Git</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>安装完毕后查看版本号</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、node的安装</h3>
<ul>
<li>brew 查找node版本</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>brew 安装node</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>node在zsh环境变量配置，安装完了有提示的，直接复制就行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>配置npm</li>
</ul>
<blockquote>
<p>遇到过 cnpm 的 bug，所以不适用 cnpm，直接配置淘宝镜像</p>
</blockquote>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 5、mysql的安装</h3>
<ul>
<li>brew查找mysql版本</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>安装</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>开机自动启动</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>mysql在zsh环境变量配置，安装完了有提示的，直接复制就行</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>连接mysql，root用户无初始密码，直接回车</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>设置root用户初始密码，为'root'</li>
</ul>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>mysql创建新的用户（必须在root用户下执行）</li>
</ul>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>mysql新用户赋予权限（必须在root用户下执行）</li>
</ul>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>mysql 删除权限</li>
</ul>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>删除用户</li>
</ul>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Reference</h2>
<ul>
<li>Homebrew 官网：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fbrew.sh" target="_blank" rel="noopener noreferrer">https://brew.sh</a></li>
<li>Homebrew<br>
Github：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FHomebrew%2Fbrew" target="_blank" rel="noopener noreferrer">https://github.com/Homebrew/brew</a></li>
<li>Homebrew 的 Manpage<br>
说明书：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.brew.sh%2FManpage" target="_blank" rel="noopener noreferrer">https://docs.brew.sh/Manpage</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://theme-hope.vuejs.press/zh/config/theme/layout.html/images/homebrew/homebrew-01.png" type="image/png"/>
    </item>
  </channel>
</rss>